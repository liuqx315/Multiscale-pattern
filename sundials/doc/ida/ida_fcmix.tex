%%==============================================================================
\chapter{FIDA, an Interface Module for FORTRAN Applications}\label{s:fcmix}
%%==============================================================================

The {\fida} interface module is a package of {\C} functions which support
the use of the {\ida} solver, for the solution of DAE systems, in a mixed
{\F}/{\C} setting.  While {\ida} is written in {\C}, it is assumed here
that the user's calling program and user-supplied problem-defining routines
are written in {\F}. This package provides the necessary interface to {\ida}
for both the serial and the parallel {\nvector} implementations.

%%==============================================================================
\section{FIDA routines}\label{sss:fidaroutines}
%%==============================================================================

\index{FIDA@{\fida} interface module!user-callable functions|(}
The user-callable functions, with the corresponding {\ida} functions,
are as follows:
\begin{itemize}
\item
  Interface to the {\nvector} modules
  \begin{itemize}
  \item \id{FNVINITS} (defined by {\nvecs}) 
    interfaces to \id{N\_VNewEmpty\_Serial}.
  \item \id{FNVINITP} (defined by {\nvecp}) 
    interfaces to \id{N\_VNewEmpty\_Parallel}.
  \end{itemize}
\item Interface to the main {\ida} module
  \begin{itemize}
  \item \id{FIDAMALLOC}
    interfaces to \id{IDACreate}, \id{IDASetUserData}, \id{IDAInit},
    \id{IDASStolerances}, and \id{IDASVtolerances}.
  \item \id{FIDAREINIT}
    interfaces to \id{IDAReInit} and \id{IDASStolerances}/\id{IDASVtolerances}.
  \item \id{FIDASETIIN}, \id{FIDASETVIN}, and \id{FIDASETRIN}
    interface to \id{IDASet*} functions.    
  \item \id{FIDATOLREINIT}
    interfaces to \id{IDASStolerances}/\id{IDASVtolerances}.
  \item \id{FIDACALCIC}
    interfaces to \id{IDACalcIC}.
  \item \id{FIDAEWTSET}
    interfaces to \id{IDAWFtolerances}.
  \item \id{FIDASOLVE}
    interfaces to \id{IDASolve}, \id{IDAGet*} functions, and to the optional
    output functions for the selected linear solver module.
  \item \id{FIDAGETDKY}
    interfaces to \id{IDAGetDky}.
  \item \id{FIDAGETERRWEIGHTS}
    interfaces to \id{IDAGetErrWeights}.
  \item \id{FIDAGETESTLOCALERR}
    interfaces to \id{IDAGetEstLocalErrors}.
  \item \id{FIDAFREE}    
    interfaces to \id{IDAFree}.
  \end{itemize}
\item Interface to the linear solver modules
  \begin{itemize}
  \item \id{FIDADENSE}
    interfaces to \id{IDADense}.
  \item \id{FIDADENSESETJAC}
    interfaces to \id{IDADlsSetDenseJacFn}.
  \item \id{FIDALAPACKDENSE}
    interfaces to \id{IDALapackDense}.
  \item \id{FIDALAPACKDENSESETJAC}
    interfaces to \id{IDADlsSetDenseJacFn}.
  \item \id{FIDABAND}
    interfaces to \id{IDABand}.
  \item \id{FIDABANDSETJAC}
    interfaces to \id{IDADlsSetBandJacFn}.
  \item \id{FIDALAPACKBAND}
    interfaces to \id{IDALapackBand}.
  \item \id{FIDALAPACKBANDSETJAC}
    interfaces to \id{IDADlsSetBandJacFn}.
  \item \id{FIDASPGMR}
    interfaces to \id{IDASpgmr} and {\spgmr} optional input functions.
  \item \id{FIDASPGMRREINIT}
    interfaces to {\spgmr} optional input functions.
  \item \id{FIDASPBCG}
    interfaces to \id{IDASpbcg} and {\spbcg} optional input functions.
  \item \id{FIDASPBCGREINIT}
    interfaces to {\spbcg} optional input functions.
  \item \id{FIDASPTFQMR}
    interfaces to \id{IDASptfqmr} and {\sptfqmr} optional input functions.
  \item \id{FIDASPTFQMRREINIT}
    interfaces to {\sptfqmr} optional input functions.
  \item \id{FIDASPILSSETJAC}
   interfaces to \id{IDASpilsSetJacTimesVecFn}.
 \item \id{FIDASPILSSETPREC}
   interfaces to \id{IDASpilsSetPreconditioner}.
 \end{itemize}

\end{itemize}
\index{FIDA@{\fida} interface module!user-callable functions|)}

\index{FIDA@{\fida} interface module!user-supplied functions}
The user-supplied functions, each listed with the corresponding internal interface
function which calls it (and its type within {\ida}), are as follows:
\begin{center}
\begin{tabular}{l||l|l}
{\fida} routine      &  {\ida} function & {\ida} type of \\
({\F}, user-supplied)  &  ({\C}, interface) & interface function \\ \hline\hline
\id{FIDARESFUN} & \id{FIDAresfn}    & \id{IDAResFn} \\
\id{FIDAEWT}    & \id{FIDAEwtSet}   & \id{IDAEwtFn} \\
\id{FIDADJAC}   & \id{FIDADenseJac} & \id{IDADlsDenseJacFn} \\
                & \id{FIDALapackDenseJac} & \id{IDADlsDenseJacFn} \\
\id{FIDABJAC}   & \id{FIDABandJac}  & \id{IDADlsBandJacFn} \\
                & \id{FIDALapackBandJac}  & \id{IDADlsBandJacFn} \\
\id{FIDAPSOL}   & \id{FIDAPSol}     & \id{IDASpilsPrecSolveFn} \\
\id{FIDAPSET}   & \id{FIDAPSet}     & \id{IDASpilsPrecSetupFn} \\
\id{FIDAJTIMES} & \id{FIDAJtimes}   & \id{IDASpilsJacTimesVecFn} \\
\end{tabular}
\end{center}
In contrast to the case of direct use of {\ida}, and of most {\F} DAE
solvers, the names of all user-supplied routines here are fixed, in
order to maximize portability for the resulting mixed-language program.

%%==============================================================================
\subsection{Important note on portability}
%%==============================================================================
\index{portability!Fortran}

In this package, the names of the interface functions, and the names of
the {\F} user routines called by them, appear as dummy names
which are mapped to actual values by a series of definitions in the
header files \id{fida.h}, \id{fidaroot.h}, and \id{fidabbd.h}.
By default, those mapping definitions depend in turn on the {\C} macros
\id{F77\_FUNC} and \id{F77\_FUNC\_} defined in the header file
\id{sundials\_config.h} and decided upon at configuration time
(see Appendix \ref{c:install}).

The user must also ensure that variables in the user {\F} code are
declared in a manner consistent with their counterparts in {\ida}.
All real variables must be declared as \id{REAL}, \id{DOUBLE PRECISION},
or perhaps as \id{REAL*}{\em n}, where {\em n} denotes the number of bytes,
depending on whether {\ida} was built in single, double, or extended precision 
(see Appendix \ref{c:install}). Moreover, some of the {\F} integer variables
must be declared as \id{INTEGER*4} or \id{INTEGER*8} according to the 
{\C} type \id{long int}. These integer variables include:
the optional input (\id{IVAL}), the problem size and bandwidth parameters
(\id{NEQ}, \id{NLOCAL}, \id{NGLOBAL}, \id{ML}, \id{MU}, etc.),
the array of integer optional outputs (\id{IOUT}),
and the user array of integer data (\id{IPAR}).
EXCEPTION: In the case that Lapack linear solvers are to be used, the
input arguments to \id{FIDALAPACKDENSE} or \id{FIDALAPACKBAND} (\id{NEQ},
\id{ML}, and \id{MU}) must be declared to be consistent with {\C} type \id{int}.
This type consistency is particularly important when using {\ida} and the
{\fida} package on 64-bit architectures.

%%==============================================================================
\section{Usage of the FIDA interface module}\label{ss:fida_usage}
%%==============================================================================
\index{FIDA@{\fida} interface module!usage|(}

The usage of {\fida} requires calls to five or more interface
functions, depending on the method options selected, and one or more
user-supplied routines which define the problem to be solved.  These
function calls and user routines are summarized separately below.
Some details are omitted, and the user is referred to the description
of the corresponding {\ida} functions for information on the arguments 
of any given user-callable interface routine, or of a given user-supplied 
function called by an interface function.
The usage of {\fida} for rootfinding, and usage of {\fida} with
preconditioner modules, are each described in later sections.

Steps marked {\s} in the instructions below apply to the serial
{\nvector} implementation ({\nvecs}) only, while those marked {\p}
apply to {\nvecp}.

\index{User main program!FIDA@{\fida} usage}
\begin{Steps}
  
\item {\bf Residual function specification}
  
  The user must in all cases supply the following {\F} routine
  \index{FIDARESFUN@\texttt{FIDARESFUN}}
\begin{verbatim}
      SUBROUTINE FIDARESFUN (T, Y, YP, R, IPAR, RPAR, IER)
      DIMENSION Y(*), YP(*), R(*), IPAR(*), RPAR(*)
\end{verbatim}
  It must set the \id{R} array to $F(t,y,\dot{y})$, the residual function of the DAE
  system, as a function of \id{T} $ = t$ and the arrays \id{Y} $ = y$ and
  \id{YP} $ = \dot{y}$.  
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.
  It should return \id{IER} = 0 if it was successful,
  \id{IER} = 1 if it had a recoverable failure, or
  \id{IER} = -1 if it had a non-recoverable failure.
  
\item  {\bf {\nvector} module initialization}

  {\s} To initialize the serial {\nvector} module, the user must make the
  following call:
  \index{FNVINITS@\texttt{FNVINITS}}
\begin{verbatim}
      CALL FNVINITS (KEY, NEQ, IER)
\end{verbatim}
  where 
  \id{KEY} is the solver id (\id{KEY} = 2 for {\ida}),
  \id{NEQ} is the size of vectors, and
  \id{IER} is a return flag, which is set to $0$ on success and $-1$ 
  if a failure occurred.
  
  {\p} To initialize the parallel vector module, the user must make the
  following call:
  \index{FNVINITP@\texttt{FNVINITP}}
\begin{verbatim}
      CALL FNVINITP (COMM, KEY, NLOCAL, NGLOBAL, IER)
\end{verbatim}
  in which the arguments are: \id{COMM} = {\mpi} communicator, \id{KEY} = 2,
  \id{NLOCAL} = the local size of all vectors on this processor, and
  \id{NGLOBAL} = the system size (and the global size of vectors, equal to the
  sum of all values of \id{NLOCAL}). The return flag \id{IER} is
  set to $0$ on a successful return and to $-1$ otherwise.

  NOTE: The integers \id{NEQ}, \id{NLOCAL}, and \id{NGLOBAL} should be
  declared so as to match {\C} type \id{long int}.

  {\warn}If the header file \id{sundials\_config.h} defines
  \id{SUNDIALS\_MPI\_COMM\_F2C} to be $1$ (meaning the {\mpi}
  implementation used to build {\sundials} includes the
  \id{MPI\_Comm\_f2c} function), then \id{COMM} can be any valid
  {\mpi} communicator. Otherwise, \id{MPI\_COMM\_WORLD} will be used, so
  just pass an integer value as a placeholder.

\item {\bf Problem specification}

  To set various problem and solution parameters and allocate
  internal memory, make the following call:
  \index{FIDAMALLOC@\texttt{FIDAMALLOC}}
  \ucfunction{FIDAMALLOC}
  {
    \begin{tabular}[t]{@{}r@{}l@{}l}
        &CALL FIDAMALLOC(&T0, Y0, YP0, IATOL, RTOL, ATOL,  \\
    {\&}&                &IOUT, ROUT, IPAR, RPAR, IER)
  \end{tabular}
  }
  {
    This function provides required problem and solution specifications, 
    specifies optional inputs,
    allocates internal memory, and initializes {\ida}.
  }
  {
    \begin{args}[IATOL]
    \item[T0] is the initial value of $t$.
    \item[Y0] is an array of initial conditions for $y$.
    \item[YP0] is an array of initial conditions for $\dot{y}$.
    \item[IATOL] specifies the type for absolute tolerance \id{ATOL}:
      $1$ for scalar or $2$ for array. If \id{IATOL}$=3$, the arguments
      \id{RTOL} and \id{ATOL} are ignored and the user is expected to
      subsequently call \id{FIDAEWTSET} and provide the function \id{FIDAEWT}.
    \item[RTOL] is the relative tolerance (scalar).
    \item[ATOL] is the absolute tolerance (scalar or array).
    \item[IOUT] is an integer array of length at least 21 for integer optional
                outputs.
    \item[ROUT] is a real array of length at least 6 for real optional outputs.
    \item[IPAR] is an integer array of user data which will be passed
      unmodified to all user-provided routines.
    \item[RPAR] is a real array of user data which will be passed
      unmodified to all user-provided routines.
    \end{args}
  }
  {
    \id{IER} is a return completion flag.  Values are $0$ for successful return
    and $-1$ otherwise. See printed message for details in case of failure.
  }
  {
    The user integer data arrays \id{IOUT} and \id{IPAR} must be declared as
    \id{INTEGER*4} or \id{INTEGER*8} according to the {\C} type \id{long int}.

    Modifications to the user data arrays \id{IPAR} and \id{RPAR} inside a 
    user-provided routine will be propagated to all subsequent calls to
    such routines.

    The optional outputs associated with the main {\ida} integrator
    are listed in Table~\ref{t:fida_out}.
  }

  As an alternative to providing tolerances in the call to \ID{FIDAMALLOC}, the
  user may provide a routine to compute the error weights used in the WRMS norm
  evaluations. If supplied, it must have the following form:
  \index{FIDAEWT@\texttt{FIDAEWT}}
\begin{verbatim}
      SUBROUTINE FIDAEWT (Y, EWT, IPAR, RPAR, IER)
      DIMENSION Y(*), EWT(*), IPAR(*), RPAR(*)
\end{verbatim}
  It must set the positive components of the error weight vector \id{EWT} for
  the calculation of the WRMS norm of \id{Y}. On return, set
  \id{IER} = 0 if \id{FIDAEWT} was successful, and nonzero otherwise.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.

  If the \id{FIDAEWT} routine is provided, then, 
  following the call to \id{FIDAMALLOC}, the user must make the call:
  \index{FIDAEWTSET@\texttt{FIDAEWTSET}}
\begin{verbatim}
      CALL FIDAEWTSET (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$ to specify use of the user-supplied error weight routine.
  The argument \id{IER} is an error return flag, which is $0$ 
  for success or non-zero if an error occurred.

%%====================
\item\label{i:fida_opt_input}{\bf Set optional inputs} 
%%====================

  Call \id{FIDASETIIN}, \id{FIDASETRIN}, and/or \id{FIDASETVIN} to set desired
  optional inputs, if any.  See \S\ref{fida_opt_inout} for details.

\item\label{i:fida_lin_solv_spec} {\bf Linear solver specification} 
  
  The variable-order, variable-coefficient \id{BDF} method used by {\ida} involves
  the solution of linear systems related to the system Jacobian
  $J = \partial F / \partial y + \alpha \partial F / \partial \dot{y}$.
  See Eq. (\ref{e:DAE_Newtoncorr}).  {\ida} presently includes seven choices for
  the treatment of these systems, and the user of {\fida} must call a routine with
  a specific name to make the desired choice.

  %%-------------------------------------------------

  {\s} {\bf Dense treatment of the linear system}
  \index{IDADENSE@{\idadense} linear solver!use in {\fida}}
  
  To use the direct dense linear solver based on the internal {\ida}
  implementation, the user must make the call:
  \index{FIDADENSE@\texttt{FIDADENSE}}
\begin{verbatim}
      CALL FIDADENSE (NEQ, IER)
\end{verbatim}
  or
\begin{verbatim}
      CALL FIDALAPACKDENSE (NEQ, IER)
\end{verbatim}
  where \id{NEQ} is the size of the DAE system, depending on whether the internal
  or a Lapack dense linear solver is to be used.
  The argument \id{IER} is an error return flag, which is $0$ 
  for success , $-1$ if a memory allocation failure occurred, or $-2$ for illegal input.
  In the case of \id{FIDALAPACKDENSE}, \id{NEQ} must be declared so as to match
  {\C} type \id{int}.

  \index{Jacobian approximation function!dense!use in {\fida}}
  As an option when using the {\dense} linear solver, the user may supply a
  routine that computes a dense approximation of the system Jacobian. If supplied,
  it must have the following form:
  \index{FIDADJAC@\texttt{FIDADJAC}}
\begin{verbatim}
      SUBROUTINE FIDADJAC (NEQ, T, Y, YP, R, DJAC, CJ, EWT, H,
     &                     IPAR, RPAR, WK1, WK2, WK3, IER)
      DIMENSION Y(*), YP(*), R(*), EWT(*), DJAC(NEQ,*), 
     &          IPAR(*), RPAR(*), WK1(*), WK2(*), WK3(*)
\end{verbatim}
  This routine must compute the Jacobian and store it columnwise in \id{DJAC}.
  The vectors \id{WK1}, \id{WK2}, and \id{WK3} of length \id{NEQ} are provided
  as work space for use in \id{FIDADJAC}.
  The input arguments \id{T}, \id{Y}, \id{YP}, \id{R}, and \id{CJ} are the
  current values of $t$, $y$, $\dot{y}$, $F(t,y,\dot{y})$, and $\alpha$, respectively.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.
  NOTE: The argument \id{NEQ} has a type consistent with {\C} type \id{long int}
  even in the case when the Lapack dense solver is to be used.

  If the user's \id{FIDADJAC} uses difference quotient approximations, it
  may need to use the error weight array \id{EWT} and current stepsize \id{H}
  in the calculation of suitable increments.  It may also need the unit
  roundoff, which can be obtained as the optional output \id{ROUT(6)},
  passed from the calling program to this routine using \id{COMMON}.

  If the \id{FIDADJAC} routine is provided, then, following the call to \id{FIDADENSE} 
  (or \id{FIDALAPACKDENSE}), the user must make the call:
  \index{FIDADENSESETJAC@\texttt{FIDADENSESETJAC}}
\begin{verbatim}
      CALL FIDADENSESETJAC (FLAG, IER)
\end{verbatim}
  or
\begin{verbatim}
      CALL FIDALAPACKDENSESETJAC (FLAG, IER)
\end{verbatim}
  respectively, with \id{FLAG} $\neq 0$ to specify use of the user-supplied Jacobian
  approximation.  The argument \id{IER} is an error return flag, which is $0$ 
  for success or non-zero if an error occurred.
  
  Optional outputs specific to the {\dense} case are listed in
  Table~\ref{t:fida_out}.

  %%-------------------------------------------------

  {\s} {\bf Band treatment of the linear system}
  \index{IDABAND@{\idaband} linear solver!use in {\fida}}
  
  The user must make the call:
  \index{FIDABAND@\texttt{FIDABAND}}
\begin{verbatim}
      CALL FIDABAND (NEQ, MU, ML, IER)
\end{verbatim}
  or
\begin{verbatim}
      CALL FIDALAPACKBAND (NEQ, MU, ML, IER)
\end{verbatim}
  depending on whether the internal or a Lapack band linear solver is to be used.
  The arguments are: \id{MU}, the upper half-bandwidth; \id{ML}, 
  the lower half-bandwidth; and \id{IER}, an error return flag, which is  
  $0$ for success , $-1$ if a memory allocation failure occurred, or $-2$ 
  in case an input has an illegal value.     
  In the case of \id{FIDALAPACKBAND}, the arguments \id{NEQ}, \id{MU}, and \id{ML}
  must be declared so as to match {\C} type \id{int}.

  \index{Jacobian approximation function!band!use in {\fida}}
  As an option when using the {\band} linear solver, the user may supply a
  routine that computes a band approximation of the system Jacobian. If supplied,
  it must have the following form:
  \index{FIDABJAC@\texttt{FIDABJAC}}
\begin{verbatim}
      SUBROUTINE FIDABJAC(NEQ, MU, ML, MDIM, T, Y, YP, R, CJ, BJAC,
     &                    EWT, H, IPAR, RPAR, WK1, WK2, WK3, IER)
      DIMENSION Y(*), YP(*), R(*), EWT(*), BJAC(MDIM,*), 
     &          IPAR(*), RPAR(*), WK1(*), WK2(*), WK3(*)
\end{verbatim}
  This routine must load the \id{MDIM} by \id{NEQ} array \id{BJAC} with the
  Jacobian matrix at the current $(t, y, \dot{y})$ in band form.  Store in
  \id{BJAC}$(k,j)$ the Jacobian element $J_{i,j}$ with $k = i - j + $\id{MU}$ + 1$
  ($k = 1 \cdots $\id{ML} + \id{MU} + 1) and $j = 1 \cdots N$. The vectors
  \id{WK1}, \id{WK2}, and \id{WK3} of length \id{NEQ} are provided as work space
  for use in \id{FIDABJAC}.
  The input arguments \id{T}, \id{Y}, \id{YP}, \id{R}, and \id{CJ} are the
  current values of $t$, $y$, $\dot{y}$, $F(t,y,\dot{y})$, and $\alpha$, respectively.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.
  NOTE: The arguments \id{NEQ}, \id{MU}, \id{ML}, and \id{MDIM} have a type
  consistent with {\C} type \id{long int} even in the case when the Lapack band
  solver is to be used.

  If the user's \id{FIDABJAC} uses difference quotient approximations, it
  may need to use the error weight array \id{EWT} and current stepsize \id{H}
  in the calculation of suitable increments.  It may also need the unit
  roundoff, which can be obtained as the optional output \id{ROUT(6)},
  passed from the calling program to this routine using \id{COMMON}.

  If the \id{FIDABJAC} routine is provided, then, following the call to
  \id{FIDABAND} (or \id{FIDALAPACKBAND}), the user must make the call:
  \index{FIDABANDSETJAC@\texttt{FIDABANDSETJAC}}
\begin{verbatim}
      CALL FIDABANDSETJAC (FLAG, IER)
\end{verbatim}
  or
\begin{verbatim}
      CALL FIDALAPACKBANDSETJAC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$ to specify use of the user-supplied Jacobian
  approximation.  The argument \id{IER} is an error return flag, which is $0$ 
  for success or non-zero if an error occurred.

  Optional outputs specific to the {\band} case are listed in
  Table~\ref{t:fida_out}.

  %%-------------------------------------------------

  {\s}{\p} {\bf SPGMR treatment of the linear systems}
  \index{IDASPGMR@{\idaspgmr} linear solver!use in {\fida}}
  
  For the Scaled Preconditioned GMRES solution of the linear systems,
  the user must make the call
  \index{FIDASPGMR@\texttt{FIDASPGMR}}
\begin{verbatim}
      CALL FIDASPGMR (MAXL, IGSTYPE, MAXRS, EPLIFAC, DQINCFAC, IER)
\end{verbatim}
  The arguments are as follows.
  \id{MAXL} is the maximum Krylov subspace dimension.
  \id{IGSTYPE} indicates the Gram-Schmidt process type: $1$ for modified,
   or $2$ for classical.
  \id{MAXRS} maximum number of restarts.
  \id{EPLIFAC} is the linear convergence tolerance factor.
  \id{DQINCFAC} is the optional increment factor used in the matrix-vector product
  $Jv$.
  For all the input arguments, a value of 0 or $0.0$ indicates the default.
  \id{IER} is an error return flag, which is $0$ to indicate success, $-1$
  if a memory allocation failure occurred, or $-2$ to indicate an illegal input.
  
  Optional outputs specific to the {\spgmr} case are listed in
  Table~\ref{t:fida_out}.

  For descriptions of the relevant optional user-supplied routines, see 
  {\bf User-supplied routines for SPGMR/SPBCG/SPTFQMR} below.

  %%-------------------------------------------------

  {\s}{\p} {\bf SPBCG treatment of the linear systems}
  \index{IDASPBCG@{\idaspbcg} linear solver!use in {\fida}}
  
  For the Scaled Preconditioned Bi-CGStab solution of the linear systems,
  the user must make the call
  \index{FIDASPBCG@\texttt{FIDASPBCG}}
\begin{verbatim}
      CALL FIDASPBCG (MAXL, EPLIFAC, DQINCFAC, IER)
\end{verbatim}
  The arguments are as follows.
  \id{MAXL} is the maximum Krylov subspace dimension.
  \id{EPLIFAC} is the linear convergence tolerance factor.
  \id{DQINCFAC} is the optional increment factor used in the matrix-vector product
  $Jv$.
  For all the input arguments, a value of 0 or $0.0$ indicates the default.
  \id{IER} is an error return flag, which is $0$ to indicate success, $-1$
  if a memory allocation failure occurred, or $-2$ to indicate an illegal input.
  
  Optional outputs specific to the {\spbcg} case are listed in
  Table~\ref{t:fida_out}.

  For descriptions of the relevant optional user-supplied routines, see 
  {\bf User-supplied routines for SPGMR/SPBCG/SPTFQMR} below.

  %%-------------------------------------------------

  {\s}{\p} {\bf SPTFQMR treatment of the linear systems}
  \index{IDASPTFQMR@{\idasptfqmr} linear solver!use in {\fida}}
  
  For the Scaled Preconditioned Transpose-Free Quasi-Minimal Residual solution of
  the linear systems, the user must make the call
  \index{FIDASPTFQMR@\texttt{FIDASPTFQMR}}
\begin{verbatim}
      CALL FIDASPTFQMR (MAXL, EPLIFAC, DQINCFAC, IER)
\end{verbatim}
  The arguments are as follows.
  \id{MAXL} is the maximum Krylov subspace dimension.
  \id{EPLIFAC} is the linear convergence tolerance factor.
  \id{DQINCFAC} is the optional increment factor used in the matrix-vector product
  $Jv$.
  For all the input arguments, a value of 0 or $0.0$ indicates the default.
  \id{IER} is an error return flag, which is $0$ to indicate success, $-1$
  if a memory allocation failure occurred, or $-2$ to indicate an illegal input.
  
  Optional outputs specific to the {\sptfqmr} case are listed in
  Table~\ref{t:fida_out}.

  For descriptions of the relevant optional user-supplied routines, see 
  below.

  %%-------------------------------------------------
  
  {\s}{\p} {\bf Functions used by SPGMR/SPBCG/SPTFQMR}
  
  An optional user-supplied routine, \id{FIDAJTIMES}, can be provided for
  Jacobian-vector products.  If it is, then, following the call to
  \id{FIDASPGMR}, \id{FIDASPBCG}, or \id{FIDASPTFQMR}, the user must make the call:
  \index{FIDASPILSSETJAC@\texttt{FIDASPILSSETJAC}}
\begin{verbatim}
      CALL FIDASPILSSETJAC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$.  The return flag \id{IER} is 0 if successful,
  or negative if a memory error occurred.

  If preconditioning is to be done, then the user must call
  \index{FIDASPILSSETPREC@\texttt{FIDASPILSSETPREC}}
\begin{verbatim}
      CALL FIDASPILSSETPREC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$.  The return flag \id{IER} is 0 if successful,
  or negative if a memory error occurred.  In addition, the user must
  supply preconditioner routines \id{FIDAPSET} and \id{FIDAPSOL}.

  %%-------------------------------------------------

  {\s}{\p} {\bf User-supplied routines for SPGMR/SPBCG/SPTFQMR}

  With treatment of the linear systems by any of the Krylov iterative
  solvers, there are three optional user-supplied routines ---
  \id{FIDAJTIMES}, \id{FIDAPSOL}, and \id{FIDAPSET}.  The specifications
  for these routines are given below.

  \index{Jacobian approximation function!Jacobian times vector!use in {\fida}}
  As an option when using any of the Krylov iterative solvers, the user may
  supply a routine that computes the product of the system Jacobian
  $J = \partial F / \partial y + \alpha \partial F / \partial \dot{y}$
  and a given vector $v$.  If supplied, it must have the following form:
  \index{FIDAJTIMES@\texttt{FIDAJTIMES}}
\begin{verbatim}
      SUBROUTINE FIDAJTIMES(T, Y, YP, R, V, FJV, CJ, EWT, H, 
     &                      IPAR, RPAR, WK1, WK2, IER)
      DIMENSION Y(*), YP(*), R(*), V(*), FJV(*), EWT(*), 
     &          IPAR(*), RPAR(*), WK1(*), WK2(*)
\end{verbatim}
  This routine must compute the product vector $Jv$, where the vector $v$ is
  stored in \id{V}, and store the product in \id{FJV}.  On return, set
  \id{IER = 0} if \id{FIDAJTIMES} was successful, and nonzero otherwise.
  The vectors \id{W1K} and \id{WK2}, of length \id{NEQ}, are
  provided as work space for use in \id{FIDAJTIMES}.
  The input arguments \id{T}, \id{Y}, \id{YP}, \id{R}, and \id{CJ} are the
  current values of $t$, $y$, $\dot{y}$, $F(t,y,\dot{y})$, and $\alpha$, respectively.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.

  If the user's \id{FIDAJTIMES} uses difference quotient approximations, it
  may need to use the error weight array \id{EWT} and current stepsize \id{H}
  in the calculation of suitable increments.  It may also need the unit
  roundoff, which can be obtained as the optional output \id{ROUT(6)},
  passed from the calling program to this routine using \id{COMMON}.

  If preconditioning is to be included, the following routine must be
  supplied, for solution of the preconditioner linear system:
  \index{FIDAPSOL@\texttt{FIDAPSOL}}
\begin{verbatim}
      SUBROUTINE FIDAPSOL(T, Y, YP, R, RV, ZV, CJ, DELTA, EWT, 
     &                    IPAR, RPAR, WK1, IER)
      DIMENSION Y(*), YP(*), R(*), RV(*), ZV(*), EWT(*), 
     &          IPAR(*), RPAR(*), WK1(*)
\end{verbatim}
  It must solve the preconditioner linear system $Pz = r$, where $r =$ \id{RV} 
  is input, and store the solution $z$ in \id{ZV}. Here $P$ is the left 
  preconditioner.
  The input arguments \id{T}, \id{Y}, \id{YP}, \id{R}, and \id{CJ} are the
  current values of $t$, $y$, $\dot{y}$, $F(t,y,\dot{y})$, and $\alpha$, respectively.
  On return, set \id{IER = 0} if \id{FIDAPSOL} was successful, set \id{IER}
  positive if a recoverable error occurred, and set \id{IER} negative if a 
  non-recoverable error occurred.

  The arguments \id{EWT} and \id{DELTA} are input and provide the error weight
  array and a scalar tolerance, respectively, for use by \id{FIDAPSOL} if it uses
  an iterative method in its solution.  In that case, the residual vector
  $\rho = r - Pz$ of the system should be made less than \id{DELTA} in weighted
  $\ell_2$ norm, i.e. $\sqrt{\sum(\rho_i * \id{EWT}[i])^2} < $ \id{DELTA}.
  The argument \id{WK1} is a work array of length \id{NEQ} for use by this
  routine.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.

  If the user's preconditioner requires that any Jacobian-related data be evaluated
  or preprocessed, then the following routine is to be used for the evaluation and 
  preprocessing of the preconditioner:
  \index{FIDAPSET@\texttt{FIDAPSET}}
\begin{verbatim}
      SUBROUTINE FIDAPSET(T, Y, YP, R, CJ, EWT, H, 
     &                    IPAR, RPAR, WK1, WK2, WK3, IER)
      DIMENSION Y(*), YP(*), R(*), EWT(*), 
     &          IPAR(*), RPAR(*), WK1(*), WK2(*), WK3(*) 
\end{verbatim}
  It must perform any evaluation of Jacobian-related data and preprocessing needed
  for the solution of the preconditioner linear systems by \id{FIDAPSOL}.
  The input arguments \id{T}, \id{Y}, \id{YP}, \id{R}, and \id{CJ} are the
  current values of $t$, $y$, $\dot{y}$, $F(t,y,\dot{y})$, and $\alpha$, respectively.
  On return, set \id{IER = 0} if \id{FIDAPSET} was successful, set \id{IER}
  positive if a recoverable error occurred, and set \id{IER} negative if a 
  non-recoverable error occurred.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.

  If the user's \id{FIDAPSET} uses difference quotient approximations, it
  may need to use the error weight array \id{EWT} and current stepsize \id{H}
  in the calculation of suitable increments.  It may also need the unit
  roundoff, which can be obtained as the optional output \id{ROUT(6)},
  passed from the calling program to this routine using \id{COMMON}.

  {\warn} If the user calls \id{FIDASPILSSETPREC}, the subroutine \id{FIDAPSET}
  must be provided, even if it is not needed, and it must return \id{IER = 0}.

\item {\bf Correct initial values}

  Optionally, to correct the initial values $y$ and/or $\dot{y}$, make the call
\begin{verbatim}
      CALL FIDACALCIC (ICOPT, TOUT1, IER)
\end{verbatim}
  (See \S\ref{ss:ivp_sol} for details.)  The arguments are as follows:
  \id{ICOPT} is 1 for initializing the algebraic components of $y$ and
  differential components of $\dot{y}$, or 2 for initializing all of $y$.
  \id{IER} is an error return flag, which is 0 for success, or negative
  for a failure (see \id{IDACalcIC} return values).

\item {\bf Problem solution}

  Carrying out the integration is accomplished by making calls as follows:
  \index{FIDASOLVE@\texttt{FIDASOLVE}}
\begin{verbatim}
      CALL FIDASOLVE (TOUT, T, Y, YP, ITASK, IER)
\end{verbatim}
  The arguments are as follows.
  \id{TOUT} specifies the next value of $t$ at which a solution is desired (input).
  \id{T} is the value of $t$ reached by the solver on output.
  \id{Y} is an array containing the computed solution vector $y$ on output.
  \id{YP} is an array containing the computed solution vector $\dot{y}$ on output.
  \id{ITASK} is a task indicator and should be set to $1$ for normal mode 
  (overshoot \id{TOUT} and interpolate), to $2$ for one-step mode 
  (return after each internal step taken), to $3$ for normal mode with
  the additional \id{tstop} constraint, or to $4$ for one-step mode 
  with the additional constraint \id{tstop}.
  \id{IER} is a completion flag and will be set to a positive value upon
  successful return or to a negative value if an error occurred. These values
  correspond to the \id{IDASolve} returns (see \S\ref{sss:idasolve} and \S\ref{s:ida_out_constants}).
  The current values of the optional outputs are available in \id{IOUT} and
  \id{ROUT} (see Table~\ref{t:fida_out}).
  
\item {\bf Additional solution output}

  After a successful return from \id{FIDASOLVE}, the routine \id{FIDAGETDKY} may
  be called to get interpolated values of $y$ or any derivative $d^k y/dt^k$
  for $k$ not exceeding the current method order, and for any value of $t$ in
  the last internal step taken by {\ida}.  The call is as follows:
  \index{FIDAGETDKY@\texttt{FIDAGETDKY}}
\begin{verbatim}
      CALL FIDAGETDKY (T, K, DKY, IER)
\end{verbatim}
  where
  \id{T} is the input value of $t$ at which solution derivative is desired,
  \id{K} is the derivative order, and
  \id{DKY} is an array containing the computed vector $y^{(K)}(t)$ on return.
  The value of \id{T} must lie between \id{TCUR - HLAST} and \id{TCUR}.
  The value of \id{K} must satisfy $0 \leq K \leq $\id{QLAST}. (See the
  optional outputs for \id{TCUR}, \id{HLAST}, and \id{QLAST}.)
  The return flag \id{IER} is set to $0$ upon successful return, or to a
  negative value to indicate an illegal input.
  
\item {\bf Problem reinitialization}

  To re-initialize the {\ida} solver for the solution of a new problem
  of the same size as one already solved, make the following call:
  \index{FIDAREINIT@\texttt{FIDAREINIT}}
\begin{verbatim}
      CALL FIDAREINIT (T0, Y0, YP0, IATOL, RTOL, ATOL, IER)
\end{verbatim}
  The arguments have the same names and meanings as those of \id{FIDAMALLOC}.
  \id{FIDAREINIT} performs the same initializations as \id{FIDAMALLOC}, but
  does no memory allocation, using instead the existing internal memory
  created by the previous \id{FIDAMALLOC} call.

  Following this call, a call to specify the linear system solver must be
  made if the choice of linear solver is being changed.  Otherwise, a call
  to reinitialize the linear solver last used may or may not be needed,
  depending on changes in the inputs to it.

  In the case of the {\band} solver, for any change in the half-bandwidth
  parameters, call \id{FIDABAND} (or \id{FIDALAPACKBAND}) as described above.

  In the case of {\spgmr}, for a change of inputs other than \id{MAXL},
  make the call
  \index{FIDASPGMRREINIT@\texttt{FIDASPGMRREINIT}}
\begin{verbatim}
      CALL FIDASPGMRREINIT (IGSTYPE, MAXRS, EPLIFAC, DQINCFAC, IER)
\end{verbatim}
  which reinitializes {\spgmr} without reallocating its memory.
  The arguments have the same names and meanings as those of \id{FIDASPGMR}.
  If \id{MAXL} is being changed, then call \id{FIDASPGMR}.

  In the case of {\spbcg}, for a change in any inputs, make the call
  \index{FIDASPBCGREINIT@\texttt{FIDASPBCGREINIT}}
\begin{verbatim}
      CALL FIDASPBCGREINIT (MAXL, EPLIFAC, DQINCFAC, IER)
\end{verbatim}
  which reinitializes {\spbcg} without reallocating its memory.
  The arguments have the same names and meanings as those of \id{FIDASPBCG}.

  In the case of {\sptfqmr}, for a change in any inputs, make the call
  \index{FIDASPTFQMRREINIT@\texttt{FIDASPTFQMRREINIT}}
\begin{verbatim}
      CALL FIDASPTFQMRREINIT (MAXL, EPLIFAC, DQINCFAC, IER)
\end{verbatim}
  which reinitializes {\sptfqmr} without reallocating its memory.
  The arguments have the same names and meanings as those of \id{FIDASPTFQMR}.

\item {\bf Memory deallocation}

  To free the internal memory created by the call to \id{FIDAMALLOC},
  make the call
  \index{FIDAFREE@\texttt{FIDAFREE}}
\begin{verbatim}
      CALL FIDAFREE
\end{verbatim}

\end{Steps}
\index{FIDA@{\fida} interface module!usage|)}

%%==============================================================================
\section{FIDA optional input and output}\label{fida_opt_inout}
%%==============================================================================
\index{FIDA@{\fida} interface module!optional input and output}

In order to keep the number of user-callable {\fida} interface routines to
a minimum, optional inputs to the {\ida} solver are passed through only
three routines: \Id{FIDASETIIN} for integer optional inputs, \Id{FIDASETRIN}
for real optional inputs, and \Id{FIDASETVIN} for real vector (array) optional
inputs.  These functions should be called as follows:
\begin{verbatim}
      CALL FIDASETIIN(KEY, IVAL, IER)
      CALL FIDASETRIN(KEY, RVAL, IER)
      CALL FIDASETVIN(KEY, VVAL, IER)
\end{verbatim}
where \id{KEY} is a quoted string indicating which optoinal input is set
(see Table \ref{t:fida_in}), \id{IVAL} is the input integer value,
\id{RVAL} is the input real value (scalar),
\id{VVAL} is the input real array, and
\id{IER} is an integer return flag which is set to $0$ on success and
a negative value if a failure occurred.
\id{IVAL} should be declared so as to match {\C} type \id{long int}.

When using \id{FIDASETVIN} to specify the variable types (\id{KEY = 'ID\_VEC'})
the components in the array \id{VVAL} must be $1.0$ to indicate a differential 
variable, or $0.0$ to indicate an algebraic variable.
Note that this array is required only if \id{FIDACALCIC} is to be called
with \id{ICOPT = 1}, or if algebraic variables are suppressed from the error
test (indicated using \id{FIDASETIIN} with \id{KEY = 'SUPPRESS\_ALG'}).
%
When using \id{FIDASETVIN} to specify optional constraints on the
solution vector (\id{KEY = 'CONSTR\_VEC'}) the components in the
array \id{VVAL} should be one of $-2.0$, $-1.0$, $0.0$, $1.0$, or $2.0$.
See the description of \id{IDASetConstraints} (\S\ref{sss:optin_main})
for details.

The optional outputs from the {\ida} solver are accessed not through
individual functions, but rather through a pair of arrays, \Id{IOUT}
(integer type) of dimension at least $21$, and \Id{ROUT} (real type) of
dimension at least $6$.  These arrays are owned (and allocated) by
the user and are passed as arguments to \id{FIDAMALLOC}.  Table
\ref{t:fida_out} lists the entries in these two arrays and specifies
the optional variable as well as the {\ida} function which is actually
called to extract the optional output.

For more details on the optional inputs and outputs, see \S\ref{ss:optional_input}
and \S\ref{ss:optional_output}.

\begin{table}
\centering
\caption{Keys for setting {\fida} optional inputs}
\label{t:fida_in}
\medskip
\begin{tabular}{|r|c|l|}
\multicolumn{3}{c}{Integer optional inputs (\id{FIDASETIIN})}\\
\hline
{\bf Key} & {\bf Optional input} & Default value \\ 
\hline
\Id{MAX\_ORD}      & Maximum LMM method order & $5$  \\
\Id{MAX\_NSTEPS}   & Maximum no. of internal steps before $t_{\mbox{\scriptsize out}}$
                   & $500$  \\
\Id{MAX\_ERRFAIL}  & Maximum no. of error test failures & $10$  \\
\Id{MAX\_NITERS}   & Maximum no. of nonlinear iterations & $4$  \\
\Id{MAX\_CONVFAIL} & Maximum no. of convergence failures & $10$  \\
\Id{SUPPRESS\_ALG}   & Suppress alg. vars. from error test (1 = TRUE)
                     & 0 (= FALSE)  \\
\Id{MAX\_NSTEPS\_IC}   & Maximum no. of steps for IC calc. & $5$  \\
\Id{MAX\_NITERS\_IC}   & Maximum no. of Newton iterations for IC calc.& $10$  \\
\Id{MAX\_NJE\_IC}  & Maximum no. of Jac. evals fo IC calc. & $4$  \\
\Id{LS\_OFF\_IC}  & Turn off line search (1 = TRUE) & 0 (= FALSE)  \\


\hline
\multicolumn{3}{c}{}\\
\multicolumn{3}{c}{Real optional inputs (\id{FIDASETRIN})}\\
\hline
{\bf Key} & {\bf Optional input} & Default value \\ 
\hline
\Id{INIT\_STEP}   & Initial step size & estimated \\
\Id{MAX\_STEP}    & Maximum absolute step size & $\infty$ \\
\Id{STOP\_TIME}   & Value of $t_{stop}$ & undefined \\
\Id{NLCONV\_COEF} & Coeff. in the nonlinear conv. test & $0.33$ \\
\Id{NLCONV\_COEF\_IC} & Coeff. in the nonlinear conv. test for IC calc.& $0.0033$ \\
\Id{STEP\_TOL\_IC} & Lower bound on Newton step for IC calc. & uround$^{2/3}$ \\
\hline
\multicolumn{3}{c}{}\\
\multicolumn{3}{c}{Real vector optional inputs (\id{FIDASETVIN})}\\
\hline
{\bf Key} & {\bf Optional input} & Default value \\ 
\hline
\Id{ID\_VEC}   & Differential/algebraic component types & undefined\\
\Id{CONSTR\_VEC}   & Inequality constraints on solution & undefined \\
\hline
\end{tabular}
\end{table}

\begin{table}
\centering
\caption{Description of the {\fida} optional output arrays \Id{IOUT} and \Id{ROUT}}
\label{t:fida_out}
\medskip
\begin{tabular}{|r|c|l|}
\multicolumn{3}{c}{Integer output array \id{IOUT}}\\\hline
{\bf Index} & {\bf Optional output} & {\ida} {\bf function} \\ 
\hline
\multicolumn{3}{|c|}{{\ida} main solver}\\
\hline
 1 & \id{LENRW}     & \id{IDAGetWorkSpace} \\
 2 & \id{LENIW}     & \id{IDAGetWorkSpace} \\
 3 & \id{NST}       & \id{IDAGetNumSteps} \\
 4 & \id{NRE}       & \id{IDAGetNumResEvals} \\
 5 & \id{NETF}      & \id{IDAGetNumErrTestFails} \\
 6 & \id{NNCFAILS}  & \id{IDAGetNonlinSolvConvFails} \\
 7 & \id{NNI}       & \id{IDAGetNumNonlinSolvIters} \\
 8 & \id{NSETUPS}   & \id{IDAGetNumLinSolvSetups} \\
 9 & \id{QLAST}     & \id{IDAGetLastOrder} \\
10 & \id{QCUR}      & \id{IDAGetCurrentOrder} \\
11 & \id{NBCKTRKOPS}& \id{IDAGetNumBacktrackOps} \\
12 & \id{NGE}       & \id{IDAGetNumGEvals} \\
\hline
\multicolumn{3}{|c|}{{\idadense} and {\idaband} linear solvers}\\
\hline
13 &  \id{LENRWLS}  & \id{IDADlsGetWorkSpace} \\ 
14 &  \id{LENIWLS}  & \id{IDADlsGetWorkSpace} \\ 
15 &  \id{LS\_FLAG} & \id{IDADlsGetLastFlag} \\
16 &  \id{NRELS}    & \id{IDADlsGetNumResEvals} \\
17 &  \id{NJE}      & \id{IDADlsGetNumJacEvals} \\ 
\hline
\multicolumn{3}{|c|}{{\idaspgmr}, {\idaspbcg}, {\idasptfqmr} linear solvers}\\
\hline
13 &  \id{LENRWLS}  & \id{IDASpilsGetWorkSpace} \\ 
14 &  \id{LENIWLS}  & \id{IDASpilsGetWorkSpace} \\ 
15 &  \id{LS\_FLAG} & \id{IDASpilsGetLastFlag} \\ 
16 &  \id{NRELS}    & \id{IDASpilsGetNumResEvals} \\
17 &  \id{NJE}      & \id{IDASpilsGetNumJtimesEvals} \\
18 &  \id{NPE}      & \id{IDASpilsGetNumPrecEvals} \\ 
19 &  \id{NPS}      & \id{IDASpilsGetNumPrecSolves} \\ 
20 &  \id{NLI}      & \id{IDASpilsGetNumLinIters} \\ 
21 &  \id{NCFL}     & \id{IDASpilsGetNumConvFails} \\
\hline
\multicolumn{3}{c}{}\\
\multicolumn{3}{c}{Real output array \id{ROUT}}\\\hline
{\bf Index} & {\bf Optional output} & {\ida} {\bf function} \\ 
\hline
 1 & \id{H0\_USED} & \id{IDAGetActualInitStep} \\
 2 & \id{HLAST}    & \id{IDAGetLastStep} \\
 3 & \id{HCUR}     & \id{IDAGetCurrentStep} \\
 4 & \id{TCUR}     & \id{IDAGetCurrentTime} \\
 5 & \id{TOLFACT}  & \id{IDAGetTolScaleFactor} \\
 6 & \id{UROUND}   & unit roundoff \\
\hline
\end{tabular}
\end{table}

In addition to the optional inputs communicated through \id{FIDASET*}
calls and the optional outputs extracted from \id{IOUT}
and \id{ROUT}, the following user-callable routines are available:

To reset the tolerances at any time, make the following call:
\index{FIDATOLREINIT@\texttt{FIDATOLREINIT}}
\begin{verbatim}
      CALL FIDATOLREINIT (IATOL, RTOL, ATOL, IER)
\end{verbatim}
The tolerance arguments have the same names and meanings as those of
\id{FIDAMALLOC}.  The error return flag \id{IER} is 0 if successful,
and negative if there was a memory failure or illegal input.

To obtain the error weight array \id{EWT}, containing the multiplicative
error weights used the WRMS norms, make the following call:
\index{FIDAGETERRWEIGHTS@\texttt{FIDAGETERRWEIGHTS}}
\begin{verbatim}
      CALL FIDAGETERRWEIGHTS (EWT, IER)
\end{verbatim}
This computes the \id{EWT} array, normally defined by Eq. (\ref{e:errwt}). 
The array \id{EWT}, of length \id{NEQ} or \id{NLOCAL}, must already have been
declared by the user.  The error return flag \id{IER} is zero if successful,
and negative if there was a memory error.

To obtain the estimated local errors, following a successful call to
\id{FIDASOLVE}, make the following call:
\index{FIDAGETESTLOCALERR@\texttt{FIDAGETESTLOCALERR}}
\begin{verbatim}
      CALL FIDAGETESTLOCALERR (ELE, IER)
\end{verbatim}
This computes the \id{ELE} array of estimated local errors as of the last
step taken.  The array \id{ELE} must already have been declared by the user.
The error return flag \id{IER} is zero if successful, and negative if there
was a memory error.

%%==============================================================================
\section{Usage of the FIDAROOT interface to rootfinding}
%%==============================================================================
\index{FIDA@{\fida} interface module!rootfinding|(}
\index{Rootfinding}

The {\fidaroot} interface package allows programs written in {\F} to
use the rootfinding feature of the {\ida} solver module.
%%
The user-callable functions in {\fidaroot}, with the corresponding
{\ida} functions, are as follows: 
\begin{itemize}
  \item \id{FIDAROOTINIT} interfaces to \id{IDARootInit}.
  \item \id{FIDAROOTINFO} interfaces to \id{IDAGetRootInfo}.
  \item \id{FIDAROOTFREE} interfaces to \id{IDARootFree}.
\end{itemize}
%%
Note that, at this time {\fidaroot} does not provide support to
specify the direction of zero-crossing that is to be monitored. 
Instead, all roots are considered. However, the actual direction
of zero-crossing is reported (through the sign of the non-zero
elements in the array \id{INFO} returned by \id{FIDAROTINFO}).

In order to use the rootfinding feature of {\ida}, the following call must
be made, after calling \id{FIDAMALLOC} but prior to calling \id{FIDASOLVE},
to allocate and initialize memory for the \id{FIDAROOT} module:
\begin{verbatim}
      CALL FIDAROOTINIT (NRTFN, IER)
\end{verbatim}
The arguments are as follows:
\id{NRTFN} is the number of root functions.
\id{IER} is a return completion flag; its values are $0$ for success, $-1$ 
if the \id{IDA} memory was \id{NULL}, and $-14$ if a memory allocation failed.

To specifiy the functions whose roots are to be found, the user must
define the following routine:
\begin{verbatim}
      SUBROUTINE FIDAROOTFN (T, Y, YP, G, IPAR, RPAR, IER)
      DIMENSION Y(*), YP(*), G(*), IPAR(*), RPAR(*)
\end{verbatim}
It must set the \id{G} array, of length \id{NRTFN}, with components
$g_i(t,y,\dot{y})$, as a function of \id{T} $= t$ and the arrays \id{Y} $= y$
and \id{YP} $= \dot{y}$.
The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
and are the same as those passed to \id{FIDAMALLOC}.
Set \id{IER} on 0 if successful, or on a non-zero value if an error occurred.

When making calls to \id{FIDASOLVE} to solve the DAE system, the occurrence
of a root is flagged by the return value \id{IER} = 2.  In that case, if
\id{NRTFN} $> 1$, the functions $g_i$ which were found to have a root can
be identified by making the following call:
\begin{verbatim}
      CALL FIDAROOTINFO (NRTFN, INFO, IER)
\end{verbatim}
The arguments are as follows: \id{NRTFN} is the number of root functions.
\id{INFO} is an integer array of length \id{NRTFN} with root information.
\id{IER} is a return completion flag; its values are $0$ for success, 
negative if there was a memory failure.  The returned values of \id{INFO(i)}
(\id{i}$ = 1,\ldots,$ \id{NRTFN}) are $0$ or $\pm 1$, such that 
\id{INFO(i)} $ = +1$ if $g_{\id{i}}$ was found to have a root and $g_{\id{i}}$ is increasing,
\id{INFO(i)} $ = -1$ if $g_{\id{i}}$ was found to have a root and $g_{\id{i}}$ is dereasing,
and \id{INFO(i)} $ = 0$ otherwise.

The total number of calls made to the root function \id{FIDAROOTFN},
denoted \id{NGE}, can be obtained from \id{IOUT(12)}.
%%
If the {\fida}/{\ida} memory block is reinitialized to solve a
different problem via a call to \id{FIDAREINIT}, then the counter
\id{NGE} is reset to zero.

To free the memory resources allocated by a prior call to \id{FIDAROOTINIT}, make
the following call:
\begin{verbatim}
      CALL FIDAROOTFREE
\end{verbatim}
See \S\ref{ss:idarootinit} for additional information on the
rootfinding feature.
\index{FIDA@{\fida} interface module!rootfinding|)}



%%==============================================================================
\section{Usage of the FIDABBD interface to IDABBDPRE}
%%==============================================================================
\index{FIDA@{\fida} interface module!interface to the {\idabbdpre} module|(}

The {\fidabbd} interface sub-module is a package of {\C} functions
which, as part of the {\fida} interface module, support the use of the
{\ida} solver with the parallel {\nvecp} module, in a combination of
any of the Krylov iterative solver modules with the {\idabbdpre} preconditioner
module (see \S\ref{sss:idabbdpre}).

The user-callable functions in this package, with the corresponding
{\ida} and {\idabbdpre} functions, are as follows: 
\begin{itemize}
\item \id{FIDABBDINIT}
  interfaces to \id{IDABBDPrecAlloc}.
\item \id{FIDABBDREINIT}
  interfaces to \id{IDABBDPrecReInit}.
\item \id{FIDABBDOPT}
  interfaces to {\idabbdpre} optional output functions.
\item \id{FIDABBDFREE}
  interfaces to \id{IDABBDPrecFree}.
\end{itemize}

In addition to the {\F} residual function \id{FIDARESFUN}, the
user-supplied functions used by this package, are listed below,
each with the corresponding interface function which calls it (and its
type within {\idabbdpre} or {\ida}):
\begin{center}
\begin{tabular}{l|l|l}
{\fidabbd} routine ({\F})  &  {\ida} function ({\C}) & {\ida} function type \\\hline
\id{FIDAGLOCFN}  & \id{FIDAgloc}     & \id{IDABBDLocalFn} \\
\id{FIDACOMMFN}  & \id{FIDAcfn}      & \id{IDABBDCommFn} \\
\id{FIDAJTIMES} & \id{FIDAJtimes}   & \id{IDASpilsJacTimesVecFn} \\
\end{tabular}
\end{center}
As with the rest of the {\fida} routines, the names of all user-supplied routines 
here are fixed, in order to maximize portability for the resulting mixed-language
program.  Additionally, based on flags discussed above in \S\ref{sss:fidaroutines},
the names of the user-supplied routines are mapped to actual values
through a series of definitions in the header file \id{fidabbd.h}.

The following is a summary of the usage of this module. Steps that are unchanged
from the main program described in \S\ref{ss:fida_usage} are grayed-out.

\index{User main program!FIDABBD@{\fidabbd} usage}
\begin{Steps}
  
\item \textcolor{gray}{\bf Residual function specification}

\item \textcolor{gray}{\bf {\nvector} module initialization}

\item \textcolor{gray}{\bf Problem specification}

\item \textcolor{gray}{\bf Set optional inputs}

\item \textcolor{gray}{\bf Iterative linear solver specification}

\item {\bf BBD preconditioner initialization}

  To initialize the {\idabbdpre} preconditioner, make the following call:
  \index{FIDABBDINIT@\texttt{FIDABBDINIT}}
\begin{verbatim}
       CALL FIDABBDINIT (NLOCAL, MUDQ, MLDQ, MU, ML, DQRELY, IER)
\end{verbatim}
  The arguments are as follows.
  \id{NLOCAL} is the local size of vectors on this processor.
  \id{MUDQ} and \id{MLDQ} are the upper and lower half-bandwidths to be used in 
  the computation of the local Jacobian blocks by difference quotients.
  These may be smaller than the true half-bandwidths of the
  Jacobian of the local block of $G$, when smaller values may
  provide greater efficiency.
  \id{MU} and \id{ML} are the upper and lower half-bandwidths of the band matrix
  that  is retained as an approximation of the local Jacobian block.
  These may be smaller than \id{MUDQ} and \id{MLDQ}.
  \id{DQRELY} is the relative increment factor in $y$ for difference quotients
  (optional). A value of $0.0$ indicates the default, $\sqrt{\text{unit roundoff}}$.
  \id{IER} is a return completion flag.  A value of $0$ indicates success, while
  a value of $-1$ indicates that a memory failure occurred or that an input had
  an illegal value.

\item \textcolor{gray}{\bf Problem solution}
  
\item {\bf {\idabbdpre} Optional outputs}

  Optional outputs specific to the {\spgmr}, {\spbcg}, or {\sptfqmr} solver are 
  listed in Table \ref{t:fida_out}.
  To obtain the optional outputs associated with the {\idabbdpre}
  module, make the following call:
  \index{FIDABBDOPT@\texttt{FIDABBDOPT}}
\begin{verbatim}
       CALL FIDABBDOPT (LENRWBBD, LENIWBBD, NGEBBD)
\end{verbatim}
  The arguments returned are as follows.
  \id{LENRWBBD} is the length of real preconditioner work space, in \id{realtype}
  words.  \id{LENIWBBD} is the length of integer preconditioner work space, in
  integer words.  Both of these sizes are local to the current processor.
  \id{NGEBBD} is the number of $G(t,y,\dot{y})$ evaluations (calls to \id{FIDALOCFN})
  so far.
  
\item {\bf Problem reinitialization}
  
  If a sequence of problems of the same size is being solved using the {\spgmr},
  {\spbcg}, or {\sptfqmr} linear solver in combination with the {\idabbdpre}
  preconditioner, then the {\ida} package can be re-initialized for the second
  and subsequent problems by calling \id{FIDAREINIT}, following which a call
  to \id{FIDABBDINIT} may or  may not be needed.
  If the input arguments are the same, no \id{FIDABBDINIT} call is needed.
  If there is a change in input arguments other than \id{MU}, \id{ML}, or
  \id{MAXL}, then the user program should make the call 
  \index{FIDABBDREINIT@\texttt{FIDABBDREINIT}}
\begin{verbatim}
       CALL FIDABBDREINIT (NLOCAL, MUDQ, MLDQ, DQRELY, IER)
\end{verbatim}
  This reinitializes the {\idabbdpre} preconditioner, but without
  reallocating its memory.  The arguments of the \id{FIDABBDREINIT}
  routine have the same names and meanings as those of \id{FIDABBDINIT}.
  If the value of \id{MU} or \id{ML} is being changed, then a call to
  \id{FIDABBDINIT} must be made.  Finally, if \id{MAXL} is being  changed,
  then a call to \id{FIDASPGMR}, \id{FIDASPBCG}, or \id{FIDASPTFQMR}
  must be made; in this case the linear solver memory is reallocated.

\item \textcolor{gray}{\bf Memory deallocation}

  (The memory allocated for the {\fidabbd} module is deallocated automatically
  by \id{FIDAFREE}.)

\index{FIDA@{\fida} interface module!interface to the {\idabbdpre} module|)}

\item {\bf User-supplied routines}

  The following two routines must be supplied for use with the {\idabbdpre}
  module:
  \index{FIDAGLOCFN@\texttt{FIDAGLOCFN}}
\begin{verbatim}
      SUBROUTINE FIDAGLOCFN (NLOC, T, YLOC, YPLOC, GLOC, IPAR, RPAR, IER)
      DIMENSION YLOC(*), YPLOC(*), GLOC(*), IPAR(*), RPAR(*)
\end{verbatim}
  This routine is to evaluate the function $G(t,y,\dot{y})$ approximating $F$
  (possibly identical to $F$), in terms of \id{T} $ = t$, and the arrays
  \id{YLOC} and \id{YPLOC} (of length \id{NLOC}), which are the sub-vectors
  of $y$ and $\dot{y}$ local to this processor.  The resulting (local) sub-vector
  is to be stored in the array \id{GLOC}.  \id{IER} is a return flag that
  should be set to 0 if successful, to 1 (for a recoverable error), or to
  -1 (for a non-recoverable error).
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.

  \index{FIDACOMMFN@\texttt{FIDACOMMFN}}
\begin{verbatim}
      SUBROUTINE FIDACOMMFN (NLOC, T, YLOC, YPLOC, IPAR, RPAR, IER)
      DIMENSION YLOC(*), YPLOC(*), IPAR(*), RPAR(*)
\end{verbatim}
  This routine is to perform the inter-processor communication necessary
  for the \id{FIDAGLOCFN} routine.
  Each call to \id{FIDACOMMFN} is preceded by a call to the residual routine
  \id{FIDARESFUN} with the same arguments \id{T}, \id{YLOC}, and \id{YPLOC}.
  Thus \id{FIDACOMMFN} can omit any communications done by \id{FIDARESFUN} if
  relevant to the evaluation of \id{GLOC}.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.
  \id{IER} is a return flag that should be set to 0 if successful, to 1
  (for a recoverable error), or to -1 (for a non-recoverable error).

  {\warn}The subroutine \id{FIDACOMMFN} must be supplied even if it is empty,
  and it must return \id{IER = 0}.

  \index{FIDAJTIMES@\texttt{FIDAJTIMES}}
  Optionally, the user can supply a routine \id{FIDAJTIMES} for the evaluation of
  Jacobian-vector products, as described above in step \ref{i:fida_lin_solv_spec}
  in \S\ref{ss:fida_usage}.

\end{Steps}
