%%==============================================================================
\chapter{FCVODE, an Interface Module for FORTRAN Applications}\label{s:fcmix}
%%==============================================================================

The {\fcvode} interface module is a package of {\C} functions which support
the use of the {\cvode} solver, for the solution of ODE systems 
$dy/dt = f(t,y)$, in a mixed {\F}/{\C} setting.  While {\cvode} is written
in {\C}, it is assumed here that the user's calling program and
user-supplied problem-defining routines are written in {\F}.
This package provides the necessary interface to {\cvode} for both the
serial and the parallel {\nvector} implementations.

%%==============================================================================
\section{FCVODE routines}\label{sss:fcvroutines}
%%==============================================================================

\index{FCVODE@{\fcvode} interface module!user-callable functions|(}
The user-callable functions, with the corresponding {\cvode} functions,
are as follows:
\begin{itemize}
\item
  Interface to the {\nvector} modules
  \begin{itemize}
  \item \id{FNVINITS} (defined by {\nvecs}) 
    interfaces to \id{N\_VNewEmpty\_Serial}.
  \item \id{FNVINITP} (defined by {\nvecp}) 
    interfaces to \id{N\_VNewEmpty\_Parallel}.
  \end{itemize}
\item Interface to the main {\cvode} module
  \begin{itemize}
  \item \id{FCVMALLOC}
    interfaces to \id{CVodeCreate}, \id{CVodeSetUserData}, and \id{CVodeInit},
    as well as one of \id{CVodeSStolerances} or \id{CVodeSVtolerances}.
  \item \id{FCVREINIT}  
    interfaces to \id{CVodeReInit}.
  \item \id{FCVSETIIN} and \id{FCVSETRIN}
    interface to \id{CVodeSet*} functions.
  \item \id{FCVEWTSET}    
    interfaces to \id{CVodeWFtolerances}.
  \item \id{FCVODE}
    interfaces to \id{CVode}, \id{CVodeGet*} functions, and to the optional
    output functions for the selected linear solver module.
  \item \id{FCVDKY}     
    interfaces to the interpolated output function \id{CVodeGetDky}.
  \item \id{FCVGETERRWEIGHTS}
    interfaces to \id{CVodeGetErrWeights}.
  \item \id{FCVGETESTLOCALERR}
    interfaces to \id{CVodeGetEstLocalErrors}.
  \item \id{FCVFREE}    
    interfaces to \id{CVodeFree}.
  \end{itemize}  
\item Interface to the linear solver modules
  \begin{itemize}
  \item \id{FCVDIAG}    
    interfaces to \id{CVDiag}.
  \item \id{FCVDENSE}
    interfaces to \id{CVDense}.
  \item \id{FCVDENSESETJAC}
    interfaces to \id{CVDlsSetDenseJacFn}.
  \item \id{FCVLAPACKDENSE}
    interfaces to \id{CVLapackDense}.
  \item \id{FCVLAPACKDENSESETJAC}
    interfaces to \id{CVDlsSetDenseJacFn}.
  \item \id{FCVBAND}
    interfaces to \id{CVBand}.
  \item \id{FCVBANDSETJAC}
    interfaces to \id{CVDlsSetBandJacFn}.
  \item \id{FCVLAPACKBAND}
    interfaces to \id{CVLapackBand}.
  \item \id{FCVLAPACKBANDSETJAC}
    interfaces to \id{CVDlsSetBandJacFn}.
  \item \id{FCVSPGMR}
    interfaces to \id{CVSpgmr} and {\spgmr} optional input functions.
  \item \id{FCVSPGMRREINIT} 
    interfaces to {\spgmr} optional input functions.
  \item \id{FCVSPBCG}
    interfaces to \id{CVSpbcg} and {\spbcg} optional input functions.
  \item \id{FCVSPBCGREINIT} 
    interfaces to {\spbcg} optional input functions.
  \item \id{FCVSPTFQMR}
    interfaces to \id{CVSptfqmr} and {\sptfqmr} optional input functions.
  \item \id{FCVSPTFQMRREINIT} 
    interfaces to {\sptfqmr} optional input functions.
  \item \id{FCVSPILSSETJAC}
    interfaces to \id{CVSpilsSetJacTimesVecFn}.
  \item \id{FCVSPILSSETPREC}
    interfaces to \id{CVSpilsSetPreconditioner}.
 \end{itemize}

\end{itemize}
\index{FCVODE@{\fcvode} interface module!user-callable functions|)}

\index{FCVODE@{\fcvode} interface module!user-supplied functions}
The user-supplied functions, each listed with the corresponding internal
interface function which calls it (and its type within {\cvode}), are as follows:
\begin{center}
\begin{tabular}{l||l|l}
{\fcvode} routine      &  {\cvode} function & {\cvode} type of \\
({\F}, user-supplied)  &  ({\C}, interface) & interface function \\ \hline\hline
\id{FCVFUN}    & \id{FCVf}              & \id{CVRhsFn} \\
\id{FCVEWT}    & \id{FCVEwtSet}         & \id{CVEwtFn} \\
\id{FCVDJAC}   & \id{FCVDenseJac}       & \id{CVDlsDenseJacFn} \\
               & \id{FCVLapackDenseJac} & \id{CVDlsDenseJacFn} \\
\id{FCVBJAC}   & \id{FCVBandJac}        & \id{CVDlsBandJacFn} \\
               & \id{FCVLapackBandJac}  & \id{CVDlsBandJacFn} \\
\id{FCVPSOL}   & \id{FCVPSol}           & \id{CVSpilsPrecSolveFn} \\
\id{FCVPSET}   & \id{FCVPSet}           & \id{CVSpilsPrecSetupFn} \\
\id{FCVJTIMES} & \id{FCVJtimes}         & \id{CVSpilsJacTimesVecFn} \\
\end{tabular}
\end{center}
In contrast to the case of direct use of {\cvode}, and of most {\F} ODE
solvers, the names of all user-supplied routines here are fixed, in
order to maximize portability for the resulting mixed-language program.

%%==============================================================================
\subsection{Important note on portability}
%%==============================================================================
\index{portability!Fortran}

In this package, the names of the interface functions, and the names of
the {\F} user routines called by them, appear as dummy names
which are mapped to actual values by a series of definitions in the
header files \id{fcvode.h}, \id{fcvroot.h}, \id{fcvbp.h}, and \id{fcvbbd.h}.
By default, those mapping definitions depend in turn on the {\C} macro
\id{F77\_FUNC} defined in the header file \id{sundials\_config.h} and
decided upon at configuration time (see Appendix \ref{c:install}).

The user must also ensure that variables in the user {\F} code are
declared in a manner consistent with their counterparts in {\cvode}.
All real variables must be declared as \id{REAL}, \id{DOUBLE PRECISION},
or perhaps as \id{REAL*}{\em n}, where {\em n} denotes the number of bytes,
depending on whether {\cvode} was built in single, double, or extended precision 
(see Appendix \ref{c:install}). Moreover, some of the {\F} integer variables
must be declared as \id{INTEGER*4} or \id{INTEGER*8} according to the 
{\C} type \id{long int}.  These integer variables include:
the optional input (\id{IVAL}), the problem size and bandwidth parameters
(\id{NEQ}, \id{NLOCAL}, \id{NGLOBAL}, \id{ML}, \id{MU}, etc.),
the array of integer optional outputs (\id{IOUT}),
and the user array of integer data (\id{IPAR}).
EXCEPTION: In the case that Lapack linear solvers are to be used, the
input arguments to \id{FCVLAPACKDENSE} or \id{FCVLAPACKBAND} (\id{NEQ},
\id{ML}, and \id{MU}) must be declared to be consistent with {\C} type \id{int}.
This type consistency is particularly important when using {\cvode} and the
{\fcvode} package on 64-bit architectures.


%%==============================================================================
\section{Usage of the FCVODE interface module}\label{ss:fcvode_usage}
%%==============================================================================
\index{FCVODE@{\fcvode} interface module!usage|(}

The usage of {\fcvode} requires calls to six or seven interface
functions, depending on the method options selected, and one or more
user-supplied routines which define the problem to be solved.  These
function calls and user routines are summarized separately below.
Some details are omitted, and the user is referred to the description
of the corresponding {\cvode} functions for information on the arguments 
of any given user-callable interface routine, or of a given user-supplied 
function called by an interface function.
The usage of {\fcvode} for rootfinding and with preconditioner modules is
described in later subsections.

Steps marked {\s} in the instructions below apply to the serial
{\nvector} implementation ({\nvecs}) only, while those marked {\p}
apply to {\nvecp}.

\index{User main program!FCVODE@{\fcvode} usage}
\begin{Steps}
  
%%====================
\item {\bf Right-hand side specification}
%%====================
  
  The user must in all cases supply the following {\F} routine
  \index{FCVFUN@\texttt{FCVFUN}}
\begin{verbatim}
      SUBROUTINE FCVFUN(T, Y, YDOT, IPAR, RPAR, IER)
      DIMENSION Y(*), YDOT(*), IPAR(*), RPAR(*)
\end{verbatim}
  It must set the \id{YDOT} array to $f(t,y)$, the right-hand side of the ODE
  system, as function of \id{T}$=t$ and the array \id{Y}$=y$.  
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FCVMALLOC}.
  \id{IER} is an error return flag which should be set to $0$ if successful, a positive
  value if a recoverable error occurred (in which case {\cvode} will attempt to correct), 
  or a negative value if it failed unrecoverably (in which case the integration is 
  halted).

%%====================
\item  {\bf {\nvector} module initialization}
%%====================

  {\s} To initialize the serial {\nvector} module, the user must make the
  following call:
  \index{FNVINITS@\texttt{FNVINITS}}
\begin{verbatim}
      CALL FNVINITS(KEY, NEQ, IER)
\end{verbatim}
  where 
  \id{KEY} is the solver id (\id{KEY} = 1 for {\cvode}),
  \id{NEQ} is the size of vectors, and
  \id{IER} is a  return completion flag which is $0$ on success and $-1$ 
  if a failure occurred.
  
  {\p} To initialize the parallel vector module, the user must make the
  following call:
  \index{FNVINITP@\texttt{FNVINITP}}
\begin{verbatim}
      CALL FNVINITP(COMM, KEY, NLOCAL, NGLOBAL, IER)
\end{verbatim}
  in which the arguments are: \id{COMM} = {\mpi} communicator,
  \id{KEY} = 1, \id{NLOCAL} = the local size of
  vectors on this processor, and \id{NGLOBAL} = the system size (and the global
  size of all vectors, equal to the sum of all values of \id{NLOCAL}).
  The return flag \id{IER} is set to $0$ on a successful return and to $-1$
  otherwise.

  NOTE: The integers \id{NEQ}, \id{NLOCAL}, and \id{NGLOBAL} should be
  declared so as to match {\C} type \id{long int}.

  {\warn}If the header file \id{sundials\_config.h} defines
  \id{SUNDIALS\_MPI\_COMM\_F2C} to be $1$ (meaning the {\mpi}
  implementation used to build {\sundials} includes the
  \id{MPI\_Comm\_f2c} function), then \id{COMM} can be any valid
  {\mpi} communicator. Otherwise, \id{MPI\_COMM\_WORLD} will be used, so
  just pass an integer value as a placeholder.

%%====================
\item {\bf Problem specification}
%%====================

  To set various problem and solution parameters and allocate
  internal memory, make the following call:
  \index{FCVMALLOC@\texttt{FCVMALLOC}}
  \ucfunction{FCVMALLOC}
  {
    \begin{tabular}[t]{@{}r@{}l@{}l}
        &CALL FCVMALLOC(&T0, Y0, METH, ITMETH, IATOL, RTOL, ATOL, \\
    {\&}&               &IOUT, ROUT, IPAR, RPAR, IER)
    \end{tabular}
  }
  {
    This function provides required problem and solution specifications, 
    specifies optional inputs,
    allocates internal memory, and initializes {\cvode}.
  }
  {
    \begin{args}[ITMETH]
    \item[T0] is the initial value of $t$.
    \item[Y0] is an array of initial conditions.
    \item[METH] specifies the  basic integration method: 
      $1$ for Adams (nonstiff) or $2$ for BDF (stiff).
    \item[ITMETH] specifies the nonlinear iteration method: 
      $1$ for functional iteration or $2$ for Newton iteration.
    \item[IATOL] specifies the type for absolute tolerance \id{ATOL}:
      $1$ for scalar or $2$ for array. If \id{IATOL}$=3$, the arguments
      \id{RTOL} and \id{ATOL} are ignored and the user is expected to
      subsequently call \id{FCVEWTSET} and provide the function \id{FCVEWT}.
    \item[RTOL] is the relative tolerance (scalar).
    \item[ATOL] is the absolute tolerance (scalar or array).
    \item[IOUT] is an integer array of length 21 for integer optional outputs.
    \item[ROUT] is a real array of length 6 for real optional outputs.
    \item[IPAR] is an integer array of user data which will be passed
      unmodified to all user-provided routines.
    \item[RPAR] is a real array of user data which will be passed
      unmodified to all user-provided routines.
    \end{args}
  }
  {
    \id{IER} is a return completion flag.  Values are $0$ for successful return
    and $-1$ otherwise. See printed message for details in case of failure.
  }
  {
    The user integer data arrays \id{IOUT} and \id{IPAR} must be declared as
    \id{INTEGER*4} or \id{INTEGER*8} according to the {\C} type \id{long int}.

    Modifications to the user data arrays \id{IPAR} and \id{RPAR} inside a 
    user-provided routine will be propagated to all subsequent calls to
    such routines.

    The optional outputs associated with the main {\cvode} integrator
    are listed in Table~\ref{t:fcvode_out}.
  }

  As an alternative to providing tolerances in the call to \ID{FCVMALLOC}, the
  user may provide a routine to compute the error weights used in the WRMS norm
  evaluations. If supplied, it must have the following form:
  \index{FCVEWT@\texttt{FCVEWT}}
\begin{verbatim}
      SUBROUTINE FCVEWT (Y, EWT, IPAR, RPAR, IER)
      DIMENSION Y(*), EWT(*), IPAR(*), RPAR(*)
\end{verbatim}
  It must set the positive components of the error weight vector \id{EWT} for
  the calculation of the WRMS norm of \id{Y}. On return, set
  \id{IER = 0} if \id{FCVEWT} was successful, and nonzero otherwise.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FCVMALLOC}.

  If the \id{FCVEWT} routine is provided, then, 
  following the call to \id{FCVMALOC}, the user must make the call:
  \index{FCVEWTSET@\texttt{FCVEWTSET}}
\begin{verbatim}
      CALL FCVEWTSET (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$ to specify use of the user-supplied error weight routine.
  The argument \id{IER} is an error return flag which is $0$ 
  for success or non-zero if an error occurred.

%%====================
\item\label{i:fcv_opt_input}{\bf Set optional inputs} 
%%====================

  Call \id{FCVINSETIIN} and/or \id{FCVINSETRIN} to set desired optional inputs,
  if any.  See \S\ref{fcv_opt_inout} for details.

%%====================
\item\label{i:fcvode_lin_solv_spec} {\bf Linear solver specification} 
%%====================
  
  In the case of a stiff system, the implicit \id{BDF} method involves the solution
  of linear systems related to the Jacobian $J = \partial f / \partial y$
  of the ODE system.  {\cvode} presently includes eight choices for the treatment
  of these systems, and the user of {\fcvode} must call a routine with a
  specific name to make the desired choice.

  %%-------------------------------------------------

  {\s} {\bf Diagonal approximate Jacobian}
  \index{CVDIAG@{\cvdiag} linear solver!use in {\fcvode}}
  
  This choice is appropriate when the Jacobian can be well approximated by
  a diagonal matrix.  The user must make the call:
  \index{FCVDIAG@\texttt{FCVDIAG}}
\begin{verbatim}
      CALL FCVDIAG(IER)
\end{verbatim}
  \id{IER} is an error return flag set on $0$ on success or $-1$ if a memory 
  failure occurred.
  There is no additional user-supplied routine. Optional outputs specific
  to the {\diag} case listed in Table~\ref{t:fcvode_out}.
  
  %%-------------------------------------------------

  {\s} {\bf Dense treatment of the linear system}
  \index{CVDENSE@{\cvdense} linear solver!use in {\fcvode}}
  
  To use the direct dense linear solver based on the internal {\cvode}
  implementation, the user must make the call:
  \index{FCVDENSE@\texttt{FCVDENSE}}
\begin{verbatim}
      CALL FCVDENSE(NEQ, IER)
\end{verbatim}
  where \id{NEQ} is the size of the ODE system.
  The argument \id{IER} is an error return flag which is $0$ for success , 
  $-1$ if a memory allocation failure occurred, or $-2$ for illegal input.

  Alternatively, to use the Lapack-based direct dense linear solver, 
  the user must make the call:
\begin{verbatim}
      CALL FCVLAPACKDENSE(NEQ, IER)
\end{verbatim}
  where the arguments have the same meanings as for \id{FCVDENSE}, except
  that here \id{NEQ} must be declared so as to match {\C} type \id{int}.

  \index{Jacobian approximation function!dense!use in {\fcvode}}
  As an option when using the {\dense} linear solver, the user may supply a
  routine that computes a dense approximation of the system Jacobian 
  $J = \partial f / \partial y$. If supplied, it must have the following form:
  \index{FCVDJAC@\texttt{FCVDJAC}}
\begin{verbatim}
      SUBROUTINE FCVDJAC (NEQ, T, Y, FY, DJAC, H, IPAR, RPAR,
     &                    WK1, WK2, WK3, IER)
      DIMENSION Y(*), FY(*), DJAC(NEQ,*), IPAR(*), RPAR(*),
     &          WK1(*), WK2(*), WK3(*)
\end{verbatim}
  Typically this routine will use only \id{NEQ}, \id{T}, \id{Y}, and \id{DJAC}. 
  It must compute the Jacobian and store it columnwise in \id{DJAC}.
  The input arguments \id{T}, \id{Y}, and \id{FY} contain the current
  values of $t$, $y$, and $f(t,y)$, respectively.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FCVMALLOC}.
  The vectors \id{WK1}, \id{WK2}, and \id{WK3}
  of length \id{NEQ} are provided as work space for use in \id{FCVDJAC}.
  \id{IER} is an error return flag which should be set to $0$ if successful, 
  a positive value if a recoverable error occurred (in which case {\cvode} will 
  attempt to correct), or a negative value if \id{FCVDJAC} failed unrecoverably 
  (in which case the integration is halted).
  NOTE: The argument \id{NEQ} has a type consistent with {\C} type \id{long int}
  even in the case when the Lapack dense solver is to be used.

  If the user's \id{FCVDJAC} uses difference quotient approximations, it
  may need to use the error weight array \id{EWT} and current stepsize \id{H}
  in the calculation of suitable increments.  The array \id{EWT} can be
  obtained by calling \id{FCVGETERRWEIGHTS} using one of the work arrays as
  temporary storage for \id{EWT}.  It may also need the unit roundoff,
  which can be obtained as the optional output \id{ROUT(6)}, passed from
  the calling program to this routine using either \id{RPAR} or a common block.

  If the \id{FCVDJAC} routine is provided, then, following the call to \id{FCVDENSE}, 
  the user must make the call:
  \index{FCVDENSESETJAC@\texttt{FCVDENSESETJAC}}
\begin{verbatim}
      CALL FCVDENSESETJAC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$ to specify use of the user-supplied Jacobian
  approximation.  The argument \id{IER} is an error return flag which is $0$ 
  for success or non-zero if an error occurred.
  If using the Lapack-based direct dense linear solver, the use of a
  Jacobian approximation supplied by the user is indicated through the call
\begin{verbatim}
      CALL FCVLAPACKDENSESETJAC (FLAG, IER)
\end{verbatim}

  Optional outputs specific to the {\dense} case are listed in
  Table~\ref{t:fcvode_out}.

  %%-------------------------------------------------

  {\s} {\bf Band treatment of the linear system}
  \index{CVBAND@{\cvband} linear solver!use in {\fcvode}}
  
  To use the direct band linear solver based on the internal {\cvode}
  implementation, the user must make the call:
  \index{FCVBAND@\texttt{FCVBAND}}
\begin{verbatim}
      CALL FCVBAND (NEQ, MU, ML, IER)
\end{verbatim}
  The arguments are: \id{MU}, the upper half-bandwidth; \id{ML}, 
  the lower half-bandwidth; and \id{IER} an error return flag which is 
  $0$ for success , $-1$ if a memory allocation failure occurred, or $-2$ 
  in case an input has an illegal value.     
  
  Alternatively, to use the Lapack-based direct band linear solver, 
  the user must make the call:
\begin{verbatim}
      CALL FCVLAPACKBAND(NEQ, MU, ML, IER)
\end{verbatim}
  where the arguments have the same meanings as for \id{FCVBAND}, except
  that here \id{NEQ}, \id{MU}, and \id{ML} must be declared so as to match
  {\C} type \id{int}.

  \index{Jacobian approximation function!band!use in {\fcvode}}
  As an option when using the {\band} linear solver, the user may supply a
  routine that computes a band approximation of the system Jacobian 
  $J = \partial f / \partial y$. If supplied, it must have the following form:
  \index{FCVBJAC@\texttt{FCVBJAC}}
\begin{verbatim}
      SUBROUTINE FCVBJAC(NEQ, MU, ML, MDIM, T, Y, FY, BJAC, H, IPAR, RPAR,
     &                   WK1, WK2, WK3, IER)
      DIMENSION Y(*), FY(*), BJAC(MDIM,*), IPAR(*), RPAR(*),
     &                WK1(*), WK2(*), WK3(*)
\end{verbatim}
  Typically this routine will use only \id{NEQ}, \id{MU}, \id{ML}, \id{T}, 
  \id{Y}, and \id{BJAC}.
  It must load the \id{MDIM} by \id{N} array \id{BJAC} with the Jacobian matrix
  at the current ($t$,$y$) in band form.  Store in \id{BJAC}$(k,j)$ the Jacobian
  element $J_{i,j}$ with $k = i - j + $ \id{MU} $ + 1$ ($k = 1 \cdots $
  \id{ML + MU + 1}) and $j = 1 \cdots N$.
  The input arguments \id{T}, \id{Y}, and \id{FY} contain the current
  values of $t$, $y$, and $f(t,y)$, respectively.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FCVMALLOC}.
  The vectors \id{WK1}, \id{WK2},
  and \id{WK3} of length \id{NEQ} are provided as work space for use in
  \id{FCVBJAC}.
  \id{IER} is an error return flag which should be set to $0$ if successful, 
  a positive value if a recoverable error occurred (in which case {\cvode} will 
  attempt to correct), or a negative value if \id{FCVBJAC} failed unrecoverably 
  (in which case the integration is halted).
  NOTE: The arguments \id{NEQ}, \id{MU}, \id{ML}, and \id{MDIM} have a type
  consistent with {\C} type \id{long int} even in the case when the Lapack band
  solver is to be used.

  If the user's \id{FCVBJAC} uses difference quotient approximations, it
  may need to use the error weight array \id{EWT} and current stepsize \id{H}
  in the calculation of suitable increments.  The array \id{EWT} can be
  obtained by calling \id{FCVGETERRWEIGHTS} using one of the work arrays as
  temporary storage for \id{EWT}.  It may also need the unit roundoff,
  which can be obtained as the optional output \id{ROUT(6)}, passed from
  the calling program to this routine using either \id{RPAR} or a common block.

  If the \id{FCVBJAC} routine is provided, then, following the call to \id{FCVBAND},
  the user must make the call:
  \index{FCVBANDSETJAC@\texttt{FCVBANDSETJAC}}
\begin{verbatim}
      CALL FCVBANDSETJAC(FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$ to specify use of the user-supplied Jacobian approximation.
  The argument \id{IER} is an error return flag which is $0$ 
  for success or non-zero if an error occurred.
  If using the Lapack-based direct band linear solver, the use of a
  Jacobian approximation supplied by the user is indicated through the call
\begin{verbatim}
      CALL FCVLAPACKNBANDSETJAC (FLAG, IER)
\end{verbatim}

  Optional outputs specific to the {\band} case are listed in Table~\ref{t:fcvode_out}.

  %%-------------------------------------------------
  
  {\s}{\p} {\bf SPGMR treatment of the linear systems}
  \index{CVSPGMR@{\cvspgmr} linear solver!use in {\fcvode}}
  
  For the Scaled Preconditioned GMRES solution of the linear systems,
  the user must make the call
  \index{FCVSPGMR@\texttt{FCVSPGMR}}
\begin{verbatim}
      CALL FCVSPGMR(IPRETYPE, IGSTYPE, MAXL, DELT, IER)
\end{verbatim}
  The arguments are as follows.
  \id{IPRETYPE} specifies the preconditioner type: 
  $0$ for no preconditioning, $1$ for left only, $2$ for right only, or $3$ for
  both sides. \id{IGSTYPE} indicates the Gram-Schmidt process type: 
  $1$ for modified G-S or $2$ for classical G-S.
  \id{MAXL} is the maximum Krylov subspace dimension.
  \id{DELT} is the linear convergence tolerance factor.
  For all of the input arguments, a value of $0$ or $0.0$ indicates the default.
  \id{IER} is an error return flag which is $0$ to indicate success, $-1$
  if a memory allocation failure occurred, or $-2$ to indicate an illegal input.
  
  Optional outputs specific to the {\spgmr} case are listed in
  Table~\ref{t:fcvode_out}.

  For descriptions of the relevant optional user-supplied routines, see 
  {\bf User-supplied routines for SPGMR/SPBCG/SPTFQMR} below.
  
  %%-------------------------------------------------
  
  {\s}{\p} {\bf SPBCG treatment of the linear systems}
  \index{CVSPBCG@{\cvspbcg} linear solver!use in {\fcvode}}
  
  For the Scaled Preconditioned Bi-CGStab solution of the linear systems,
  the user must make the call
  \index{FCVSPBCG@\texttt{FCVSPBCG}}
\begin{verbatim}
      CALL FCVSPBCG(IPRETYPE, MAXL, DELT, IER)
\end{verbatim}
  Its arguments are the same as those with the same names for \id{FCVSPGMR}.

  Optional outputs specific to the {\spbcg} case are listed in
  Table~\ref{t:fcvode_out}.

  For descriptions of the relevant optional user-supplied routines, see 
  {\bf User-supplied routines for SPGMR/SPBCG/SPTFQMR} below.
  
  %%-------------------------------------------------
  
  {\s}{\p} {\bf SPTFQMR treatment of the linear systems}
  \index{CVSPTFQMR@{\cvsptfqmr} linear solver!use in {\fcvode}}
  
  For the Scaled Preconditioned Transpose-Free Quasi-Minimal Residual solution 
  of the linear systems, the user must make the call
  \index{FCVSPTFQMR@\texttt{FCVSPTFQMR}}
\begin{verbatim}
      CALL FCVSPTFQMR(IPRETYPE, MAXL, DELT, IER)
\end{verbatim}
  Its arguments are the same as those with the same names for \id{FCVSPGMR}.

  Optional outputs specific to the {\sptfqmr} case are listed in
  Table~\ref{t:fcvode_out}.

  For descriptions of the relevant optional user-supplied routines, see below.
  
  %%-------------------------------------------------

  {\s}{\p} {\bf Functions used by SPGMR/SPBCG/SPTFQMR}

  An optional user-supplied routine, \id{FCVJTIMES} (see below), can be provided for
  Jacobian-vector products.  If it is, then, following the call to
  \id{FCVSPGMR}, \id{FCVSPBCG}, or \id{FCVSPTFQMR}, the user must make the call:
  \index{FCVSPILSSETJAC@\texttt{FCVSPILSSETJAC}}
\begin{verbatim}
      CALL FCVSPILSSETJAC(FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$ to specify use of the user-supplied
  Jacobian-times-vector approximation.
  The argument \id{IER} is an error return flag which is $0$ 
  for success or non-zero if an error occurred.
  
  If preconditioning is to be done (\id{IPRETYPE} $\neq 0$), then the user must call
  \index{FCVSPILSSETPREC@\texttt{FCVSPILSSETPREC}}
\begin{verbatim}
      CALL FCVSPILSSETPREC(FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$.  The return flag \id{IER} is 0 if
  successful, or negative if a memory error occurred.
  In addition, the user program must include
  preconditioner routines \id{FCVPSOL} and \id{FCVPSET} (see below).

  %%-------------------------------------------------

 {\s}{\p} {\bf User-supplied routines for SPGMR/SPBCG/SPTFQMR}

  With treatment of the linear systems by any of the Krylov iterative
  solvers, there are three optional user-supplied routines ---
  \id{FCVJTIMES}, \id{FCVPSOL}, and \id{FCVPSET}.  The specifications
  for these routines are given below.

  \index{Jacobian approximation function!Jacobian times vector!use in {\fcvode}}
  As an option when using the {\spgmr}, {\spbcg}, or {\sptfqmr}  linear solvers, 
  the user may supply a routine that computes the product of the system Jacobian 
  $J = \partial f / \partial y$ 
  and a given vector $v$.  If supplied, it must have the following form:
  \index{FCVJTIMES@\texttt{FCVJTIMES}}
\begin{verbatim}
      SUBROUTINE FCVJTIMES (V, FJV, T, Y, FY, H, IPAR, RPAR, WORK, IER)
      DIMENSION V(*), FJV(*), Y(*), FY(*), IPAR(*), RPAR(*), WORK(*)
\end{verbatim}
  Typically this routine will use only \id{NEQ}, \id{T}, \id{Y}, \id{V}, and
  \id{FJV}.  It must compute the product vector $Jv$, where the vector $v$ is
  stored in \id{V}, and store the product in \id{FJV}.  
  The input arguments \id{T}, \id{Y}, and \id{FY} contain the current
  values of $t$, $y$, and $f(t,y)$, respectively.  On return, set
  \id{IER = 0} if \id{FCVJTIMES} was successful, and nonzero otherwise.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FCVMALLOC}.
  The vector \id{WORK}, of length \id{NEQ}, is
  provided as work space for use in \id{FCVJTIMES}.

  If preconditioning is to be included, the following routine must be
  supplied, for solution of the preconditioner linear system:
  \index{FCVPSOL@\texttt{FCVPSOL}}
\begin{verbatim}
      SUBROUTINE FCVPSOL(T, Y, FY, R, Z, GAMMA, DELTA, LR, IPAR, RPAR,
     &                   WORK, IER)
      DIMENSION Y(*), FY(*), R(*), Z(*), IPAR(*), RPAR(*), WORK(*)
\end{verbatim}
  It must solve the preconditioner linear system $Pz = r$, where $r =$ \id{R} 
  is input, and store the solution $z$ in \id{Z}. Here $P$ is the left 
  preconditioner if \id{LR=1} and the right preconditioner if \id{LR=2}.  
  The preconditioner (or the product of the left and right preconditioners 
  if both are nontrivial) should be an  approximation to the matrix 
  $I - \gamma J$, where $I$ is the identity matrix, $J$ is the system Jacobian,
  and $\gamma =$ \id{GAMMA}.
  The input arguments \id{T}, \id{Y}, and \id{FY} contain the current
  values of $t$, $y$, and $f(t,y)$, respectively.
  On return, set \id{IER = 0} if \id{FCVPSOL} was successful, set \id{IER}
  positive if a recoverable error occurred, and set \id{IER} negative if a 
  non-recoverable error occurred.

  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FCVMALLOC}.
  The argument \id{WORK} is a work array of length \id{NEQ} for use by this
  routine.

  If the user's preconditioner requires that any Jacobian related data be evaluated
  or preprocessed, then the following routine can be used for the evaluation and 
  preprocessing of the preconditioner:
  \index{FCVPSET@\texttt{FCVPSET}}
\begin{verbatim}
      SUBROUTINE FCVPSET(T, Y, FY, JOK, JCUR, GAMMA, H, IPAR, RPAR,
     &                   WORK1, WORK2, WORK3, IER)
      DIMENSION Y(*), FY(*), EWT(*), IPAR(*), RPAR(*), 
     &          WORK1(*), WORK2(*), WORK3(*) 
\end{verbatim}
  It must perform any evaluation of Jacobian-related data and preprocessing needed
  for the solution of the preconditioner linear systems by \id{FCVPSOL}.
  The input argument \id{JOK} allows for Jacobian data to be saved and reused:
  If \id{JOK = 0}, this data should be recomputed from scratch. If \id{JOK = 1},
  a saved copy of it may be reused, and the preconditioner constructed from it.
  The input arguments \id{T}, \id{Y}, and \id{FY} contain the current
  values of $t$, $y$, and $f(t,y)$, respectively.
  On return, set \id{JCUR = 1} if Jacobian data was computed, and set
  \id{JCUR = 0} otherwise.
  Also on return, set \id{IER = 0} if \id{FCVPSET} was successful, set \id{IER}
  positive if a recoverable error occurred, and set \id{IER} negative if a 
  non-recoverable error occurred.
  
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FCVMALLOC}.
  The arguments \id{WORK1}, \id{WORK2}, \id{WORK3} are work arrays of length 
  \id{NEQ} for use by this routine.

  {\warn}If the user calls \id{FCVSPILSSETPREC}, the routine \id{FCVPSET} must
  be provided, even if it is not needed, and it must return \id{IER=0}.

  {\bf Notes} 
  \begin{itemize}
  \item[(a) ] If the user's \id{FCVJTIMES} or \id{FCVPSET} routine uses difference
    quotient approximations, it may need to use the error weight array \id{EWT},
    the current stepsize \id{H}, and/or the unit roundoff, in the calculation of
    suitable increments.  Also, If \id{FCVPSOL} uses an iterative method in its
    solution, the residual vector $\rho = r - Pz$ of the system should be made
    less than \id{DELTA} in weighted $\ell_2$ norm, i.e.
    $\sqrt{\sum(\rho_i * \id{EWT}[i])^2} < $ \id{DELTA}.
  \item[(b) ] If needed in \id{FCVJTIMES}, \id{FCVPSOL}, or \id{FCVPSET}, the
    error weight array \id{EWT} can be obtained by calling \id{FCVGETERRWEIGHTS}
    using one of the work arrays as temporary storage for \id{EWT}.
  \item[(c) ] If needed in \id{FCVJTIMES}, \id{FCVPSOL}, or \id{FCVPSET}, the
    unit roundoff can be obtained as the optional output \id{ROUT(6)}
    (available after the call to \id{FCVMALLOC}) and can be passed
    using either the \id{RPAR} user data array or a common block.
  \end{itemize}

%%====================
\item {\bf Problem solution}
%%====================

  Carrying out the integration is accomplished by making calls as follows:
  \index{FCVODE@\texttt{FCVODE}}
\begin{verbatim}
      CALL FCVODE(TOUT, T, Y, ITASK, IER)
\end{verbatim}
  The arguments are as follows.
  \id{TOUT} specifies the next value of $t$ at which a solution is desired (input).
  \id{T} is the value of $t$ reached by the solver on output.
  \id{Y} is an array containing the computed solution on output.
  \id{ITASK} is a task indicator and should be set to $1$ for normal mode 
  (overshoot \id{TOUT} and interpolate), to $2$ for one-step mode 
  (return after each internal step taken), to $3$ for normal mode with
  the additional \id{tstop} constraint, or to $4$ for one-step mode 
  with the additional constraint \id{tstop}.
  \id{IER} is a completion flag and will be set to a positive value upon
  successful return or to a negative value if an error occurred. These values
  correspond to the \id{CVode} returns (see \S\ref{sss:cvode} and \S\ref{s:cvode_out_constants}).
  The current values of the optional outputs are available in \id{IOUT} and
  \id{ROUT} (see Table~\ref{t:fcvode_out}).
  
%%====================
\item {\bf Additional solution output}
%%====================

  After a successful return from \id{FCVODE}, the routine \id{FCVDKY} may be
  used to obtain a derivative of the solution, of order up to the current method
  order, at any $t$ within the last step taken.  For this, make the following call:
  \index{FCVDKY@\texttt{FCVDKY}}
\begin{verbatim}
      CALL FCVDKY(T, K, DKY, IER)
\end{verbatim}
  where
  \id{T} is the value of $t$ at which solution derivative is desired, and
  \id{K} is the derivative order ($0 \le$ \id{K} $\le$ \id{QU}).
  On return, \id{DKY} is an array containing the computed \id{K}-th derivative
  of $y$.  The value \id{T} must lie between \id{TCUR - HU} and \id{TCUR}.
  The return flag \id{IER} is set to $0$ upon successful return or to a negative
  value to indicate an illegal input.
  
%%====================
\item {\bf Problem reinitialization}
%%====================

  To re-initialize the {\cvode} solver for the solution of a new problem
  of the same size as one already solved, make the following call:
  \index{FCVREINIT@\texttt{FCVREINIT}}
\begin{verbatim}
      CALL FCVREINIT(T0, Y0, IATOL, RTOL, ATOL, IER)
\end{verbatim}
  The arguments have the same names and meanings as those of \id{FCVMALLOC}.
  \id{FCVREINIT} performs the same initializations as
  \id{FCVMALLOC}, but does no memory allocation, using instead the existing
  internal memory created by the previous \id{FCVMALLOC} call.  The call to
  specify the linear system solution method may or may not be needed.

  Following this call, a call to specify the linear system solver must be
  made if the choice of linear solver is being changed.  Otherwise, a call
  to reinitialize the linear solver last used may or may not be needed,
  depending on changes in the inputs to it.

  In the case of the {\band} solver, for any change in the half-bandwidth
  parameters, call \id{FCVBAND} (or \id{FCVLAPACKBAND}) as described above.

  In the case of {\spgmr}, for a change of inputs other than \id{MAXL},
  make the call
  \index{FCVSPGMRREINIT@\texttt{FCVSPGMRREINIT}}
\begin{verbatim}
      CALL FCVSPGMRREINIT (IPRETYPE, IGSTYPE, DELT, IER)
\end{verbatim}
  which reinitializes {\spgmr} without reallocating its memory.
  The arguments have the same names and meanings as those of \id{FCVSPGMR}.
  If \id{MAXL} is being changed, then call \id{FCVSPGMR} instead.

  In the case of {\spbcg}, for a change in any inputs, make the call
  \index{FCVSPBCGREINIT@\texttt{FCVSPBCGREINIT}}
\begin{verbatim}
      CALL FCVSPBCGREINIT (IPRETYPE, MAXL, DELT, IER)
\end{verbatim}
  which reinitializes {\spbcg} without reallocating its memory.
  The arguments have the same names and meanings as those of \id{FCVSPBCG}.

  In the case of {\sptfqmr}, for a change in any inputs, make the call
  \index{FCVSPTFQMRREINIT@\texttt{FCVSPTFQMRREINIT}}
\begin{verbatim}
      CALL FCVSPTFQMRREINIT (IPRETYPE, MAXL, DELT, IER)
\end{verbatim}
  which reinitializes {\sptfqmr} without reallocating its memory.
  The arguments have the same names and meanings as those of \id{FCVSPTFQMR}.


%%====================
\item {\bf Memory deallocation}
%%====================

  To free the internal memory created by the call to \id{FCVMALLOC},
  make the call
  \index{FCVFREE@\texttt{FCVFREE}}
\begin{verbatim}
      CALL FCVFREE
\end{verbatim}

\end{Steps}
\index{FCVODE@{\fcvode} interface module!usage|)}


%%==============================================================================
\section{FCVODE optional input and output}\label{fcv_opt_inout}
%%==============================================================================
\index{FCVODE@{\fcvode} interface module!optional input and output}

In order to keep the number of user-callable {\fcvode} interface routines to
a minimum, optional inputs to the {\cvode} solver are passed through only
two routines: \Id{FCVSETIIN} for integer optional inputs and \Id{FCVSETRIN}
for real optional inputs. These functions should be called as follows:
\begin{verbatim}
      CALL FCVSETIIN(KEY, IVAL, IER)
      CALL FCVSETRIN(KEY, RVAL, IER)
\end{verbatim}
where \id{KEY} is a quoted string indicating which optoinal input is set
(see Table \ref{t:fcvode_in}),
\id{IVAL} is the integer input value to be used,
\id{RVAL} is the real input value to be used, and
\id{IER} is an integer return flag which is set to $0$ on success and 
a negative value if a failure occurred.
The integer \id{IVAL} should be declared in a manner consistent with {\C}
type \id{long int}.

The optional outputs from the {\cvode} solver are accessed not through
individual functions, but rather through a pair of arrays, \Id{IOUT}
(integer type) of dimension at least $21$, and \Id{ROUT} (real type) of
dimension at least $6$.  These arrays are owned (and allocated) by the user
and are passed as arguments to \id{FCVMALLOC}.
Table \ref{t:fcvode_out} lists the entries in these two arrays and specifies the
optional variable as well as the {\cvode} function which is actually called to
extract the optional output.

For more details on the optional inputs and outputs, see \S\ref{ss:optional_input}
and \S\ref{ss:optional_output}.

\begin{table}
\centering
\caption{Keys for setting {\fcvode} optional inputs}
\label{t:fcvode_in}
\medskip
\begin{tabular}{|r|c|l|}
\multicolumn{3}{c}{Integer optional inputs (\id{FCVSETIIN})}\\
\hline
{\bf Key} & {\bf Optional input} & Default value \\ 
\hline
\Id{MAX\_ORD}      & Maximum LMM method order & $5$ (BDF), $12$ (Adams)  \\
\Id{MAX\_NSTEPS}   & Maximum no. of internal steps before $t_{\mbox{\scriptsize out}}$ & $500$  \\
\Id{MAX\_ERRFAIL}  & Maximum no. of error test failures & $7$  \\
\Id{MAX\_NITERS}   & Maximum no. of nonlinear iterations & $3$  \\
\Id{MAX\_CONVFAIL} & Maximum no. of convergence failures & $10$  \\
\Id{HNIL\_WARNS}   & Maximum no. of warnings for $t_n+h=t_n$  & $10$  \\
\Id{STAB\_LIM}     & Flag to activate stability limit detection & $0$  \\
\hline
\multicolumn{3}{c}{}\\
\multicolumn{3}{c}{Real optional inputs (\id{FCVSETRIN})}\\
\hline
{\bf Key} & {\bf Optional input} & Default value \\ 
\hline
\Id{INIT\_STEP}   & Initial step size & estimated \\
\Id{MAX\_STEP}    & Maximum absolute step size & $\infty$ \\
\Id{MIN\_STEP}    & Minimum absolute step size & $0.0$ \\
\Id{STOP\_TIME}   & Value of $t_{stop}$ & undefined \\
\Id{NLCONV\_COEF} & Coefficient in the nonlinear convergence test & $0.1$ \\
\hline
\end{tabular}
\end{table}

\begin{table}
\centering
\caption{Description of the {\fcvode} optional output arrays \Id{IOUT} and \Id{ROUT}}
\label{t:fcvode_out}
\medskip
\begin{tabular}{|r|c|l|}
\multicolumn{3}{c}{Integer output array \id{IOUT}}\\
\hline
{\bf Index} & {\bf Optional output} & {\cvode} {\bf function} \\ 
\hline
\multicolumn{3}{|c|}{{\cvode} main solver}\\
\hline
1  &  \id{LENRW}   & \id{CVodeGetWorkSpace} \\
2  &  \id{LENIW}   & \id{CVodeGetWorkSpace} \\
3  &  \id{NST}     & \id{CVodeGetNumSteps} \\
4  &  \id{NFE}     & \id{CVodeGetNumRhsEvals} \\
5  &  \id{NETF}    & \id{CVodeGetNumErrTestFails} \\
6  &  \id{NCFN}    & \id{CVodeGetNumNonlinSolvConvFails} \\
7  &  \id{NNI}     & \id{CVodeGetNumNonlinSolvIters} \\
8  &  \id{NSETUPS} & \id{CVodeGetNumLinSolvSetups} \\
9  &  \id{QU}      & \id{CVodeGetLastOrder} \\
10 &  \id{QCUR}    & \id{CVodeGetCurrentOrder} \\
11 &  \id{NOR}     & \id{CVodeGetNumStabLimOrderReds} \\ 
12 &  \id{NGE}     & \id{CVodeGetNumGEvals} \\ 
\hline
\multicolumn{3}{|c|}{{\cvdense}, {\cvband} linear solvers}\\
\hline
13 & \id{LENRWLS}  & \id{CVDlsGetWorkSpace} \\ 
14 & \id{LENIWLS}  & \id{CVDlsGetWorkSpace} \\ 
15 & \id{LS\_FLAG} & \id{CVDlsGetLastFlag} \\ 
16 & \id{NFELS}    & \id{CVDlsGetNumRhsEvals} \\ 
17 & \id{NJE}      & \id{CVDlsGetNumJacEvals} \\ 
\hline
\multicolumn{3}{|c|}{{\cvdiag} linear solver}\\
\hline
13 & \id{LENRWLS}  & \id{CVDiagGetWorkSpace} \\ 
14 & \id{LENIWLS}  & \id{CVDiagGetWorkSpace} \\ 
15 & \id{LS\_FLAG} & \id{CVDiagGetLastFlag} \\ 
16 & \id{NFELS}    & \id{CVDiagGetNumRhsEvals} \\ 
\hline
\multicolumn{3}{|c|}{{\cvspgmr}, {\cvspbcg}, {\cvsptfqmr} linear solvers}\\
\hline
13 & \id{LENRWLS}  & \id{CVSpilsGetWorkSpace} \\ 
14 & \id{LENIWLS}  & \id{CVSpilsGetWorkSpace} \\ 
15 & \id{LS\_FLAG} & \id{CVSpilsGetLastFlag} \\ 
16 & \id{NFELS}    & \id{CVSpilsGetNumRhsEvals} \\ 
17 & \id{NJTV}     & \id{CVSpilsGetNumJacEvals} \\ 
18 & \id{NPE}      & \id{CVSpilsGetNumPrecEvals} \\ 
19 & \id{NPS}      & \id{CVSpilsGetNumPrecSolves} \\ 
20 & \id{NLI}      & \id{CVSpilsGetNumLinIters} \\ 
21 & \id{NCFL}     & \id{CVSpilsGetNumConvFails} \\
\hline
\multicolumn{3}{c}{}\\
\multicolumn{3}{c}{Real output array \id{ROUT}}\\
\hline
{\bf Index} & {\bf Optional output} & {\cvode} {\bf function} \\ 
\hline
%
1  & \id{H0U}     & \id{CVodeGetActualInitStep} \\
2  & \id{HU}      & \id{CVodeGetLastStep} \\
3  & \id{HCUR}    & \id{CVodeGetCurrentStep} \\
4  & \id{TCUR}    & \id{CVodeGetCurrentTime} \\
5  & \id{TOLSF}   & \id{CVodeGetTolScaleFactor} \\
6  & \id{UROUND}  & unit roundoff \\
\hline
%
\end{tabular}
\end{table}                                                                  

In addition to the optional inputs communicated through \id{FCVSET*}
calls and the optional outputs extracted from \id{IOUT} and \id{ROUT},
the following user-callable routines are available:

To obtain the error weight array \id{EWT}, containing the multiplicative
error weights used the WRMS norms, make the following call:
\index{FCVGETERRWEIGHTS@\texttt{FCVGETERRWEIGHTS}}
\begin{verbatim}
      CALL FCVGETERRWEIGHTS (EWT, IER)
\end{verbatim}
This computes the \id{EWT} array normally defined by Eq. (\ref{e:errwt}).
The array \id{EWT}, of length \id{NEQ} or \id{NLOCAL}, must already have been
declared by the user.  The error return flag \id{IER} is zero if successful,
and negative if there was a memory error.

To obtain the estimated local errors, following a successful call to
\id{FCVSOLVE}, make the following call:
\index{FCVGETESTLOCALERR@\texttt{FCVGETESTLOCALERR}}
\begin{verbatim}
      CALL FCVGETESTLOCALERR (ELE, IER)
\end{verbatim}
This computes the \id{ELE} array of estimated local errors as of the last
step taken.  The array \id{ELE} must already have been declared by the user.
The error return flag \id{IER} is zero if successful, and negative if there
was a memory error.


%%==============================================================================
\section{Usage of the FCVROOT interface to rootfinding}
%%==============================================================================
\index{FCVODE@{\fcvode} interface module!rootfinding|(}
\index{Rootfinding}

The {\fcvroot} interface package allows programs written in {\F} to
use the rootfinding feature of the {\cvode} solver module.
%%
The user-callable functions in {\fcvroot}, with the corresponding
{\cvode} functions, are as follows: 
\begin{itemize}
  \item \id{FCVROOTINIT} interfaces to \id{CVodeRootInit}.
  \item \id{FCVROOTINFO} interfaces to \id{CVodeGetRootInfo}.
  \item \id{FCVROOTFREE} interfaces to \id{CVodeRootFree}.
\end{itemize}
%%
Note that at this time, {\fcvroot} does not provide support to
specify the direction of zero-crossing that is to be monitored. 
Instead, all roots are considered. However, the actual direction
of zero-crossing is reported (through the sign of the non-zero
elements in the array \id{INFO} returned by \id{FCVROTINFO}).

In order to use the rootfinding feature of {\cvode}, the following
call must be made, after calling \id{FCVMALLOC} but prior to calling
\id{FCVODE}, to allocate and initialize memory for the \id{FCVROOT} module:
\begin{verbatim}
      CALL FCVROOTINIT (NRTFN, IER)
\end{verbatim}
The arguments are as follows:
\id{NRTFN} is the number of root functions.
\id{IER} is a return completion flag; its values are $0$ for success, $-1$ 
if the \id{CVODE} memory was \id{NULL}, and $-11$ if a memory allocation failed.

To specifiy the functions whose roots are to be found, the user must
define the following routine:
\begin{verbatim}
      SUBROUTINE FCVROOTFN (T, Y, G, IPAR, RPAR, IER)
      DIMENSION Y(*), G(*), IPAR(*), RPAR(*)
\end{verbatim}
It must set the \id{G} array, of length \id{NRTFN}, with components $g_i(t,y)$,
as a function of \id{T} $= t$ and the array \id{Y} $= y$.  
The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
and are the same as those passed to \id{FCVMALLOC}.
Set \id{IER} on 0 if successful, or on a non-zero value if an error occurred.

When making calls to \id{FCVODE} to solve the ODE system, the occurrence of
a root is flagged by the return value \id{IER} = 2.  In that case, if
\id{NRTFN} $> 1$, the functions $g_i$ which were found to have a root can
be identified by making the following call:
\begin{verbatim}
      CALL FCVROOTINFO (NRTFN, INFO, IER)
\end{verbatim}
The arguments are as follows: \id{NRTFN} is the number of root functions.
\id{INFO} is an integer array of length \id{NRTFN} with root information.
\id{IER} is a return completion flag; its values are $0$ for success, 
negative if there was a memory failure.  The returned values of \id{INFO(i)}
(\id{i}$ = 1,\ldots,$ \id{NRTFN}) are $0$ or $\pm 1$, such that 
\id{INFO(i)} $ = +1$ if $g_{\id{i}}$ was found to have a root and $g_{\id{i}}$ is increasing,
\id{INFO(i)} $ = -1$ if $g_{\id{i}}$ was found to have a root and $g_{\id{i}}$ is dereasing,
and \id{INFO(i)} $ = 0$ otherwise.

The total number of calls made to the root function \id{FCVROOTFN},
denoted \id{NGE}, can be obtained from \id{IOUT(12)}.
%%
If the {\fcvode}/{\cvode} memory block is reinitialized to solve a
different problem via a call to \id{FCVREINIT}, then the counter
\id{NGE} is reset to zero.

To free the memory resources allocated by a prior call to \id{FCVROOTINIT}, make
the following call:
\begin{verbatim}
      CALL FCVROOTFREE
\end{verbatim}
\index{FCVODE@{\fcvode} interface module!rootfinding|)}


%%==============================================================================
\section{Usage of the FCVBP interface to CVBANDPRE}
%%==============================================================================
\index{FCVODE@{\fcvode} interface module!interface to the {\cvbandpre} module|(}
%%
The {\fcvbp} interface sub-module is a package of {\C} functions which,
as part of the {\fcvode} interface module, support the use of the
{\cvode} solver with the serial {\nvecs} module, and the combination of
the {\cvbandpre} preconditioner module (see \S\ref{sss:cvbandpre}) with
any of the Krylov iterative linear solvers.

The two user-callable functions in this package, with the corresponding
{\cvode} function around which they wrap, are:
\begin{itemize}
\item \id{FCVBPINIT}
  interfaces to \id{CVBandPrecInit}.
\item \id{FCVBPOPT}
  interfaces to {\cvbandpre} optional output functions.
\end{itemize}

As with the rest of the {\fcvode} routines, the names of the user-supplied
routines are mapped to actual values through a series of definitions in the
header file \id{fcvbp.h}.

The following is a summary of the usage of this module. Steps that are unchanged
from the main program described in \S\ref{ss:fcvode_usage} are grayed-out.

\index{User main program!FCVBP@{\fcvbp} usage}
\begin{Steps}
  
\item \textcolor{gray}{\bf Right-hand side specification}

\item \textcolor{gray}{\bf {\nvector} module initialization}

\item \textcolor{gray}{\bf Problem specification}

\item \textcolor{gray}{\bf Set optional inputs}

\item {\bf Linear solver specification}

  First, specify one of the {\cvspils} iterative linear solvers, by calling
  one of \id{FCVSPGMR}, \id{FCVSPBCG}, or \id{FCVSPTFQMR}.

  Then, to initialize the {\cvbandpre} preconditioner, make the following call:
  \index{FCVBPINIT@\texttt{FCVBPINIT}}
\begin{verbatim}
       CALL FCVBPINIT(NEQ, MU, ML, IER)
\end{verbatim}
  The arguments are as follows.
  \id{NEQ} is the problem size.
  \id{MU} and \id{ML} are the upper and lower half-bandwidths of the band matrix
  that  is retained as an approximation of the Jacobian.
  \id{IER} is a return completion flag.  A value of $0$ indicates success, while 
  a value of $-1$ indicates that a memory failure occurred.
    
  Optionally, to specify that {\spgmr}, {\spbcg}, or {\sptfqmr} should use 
  the supplied \id{FCVJTIMES}, make the call
  \index{FCVSPILSSETJAC@\texttt{FCVSPILSSETJAC}}
\begin{verbatim}
       CALL FCVSPILSSETJAC(FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$ 
  (see step \ref{i:fcvode_lin_solv_spec} in \S\ref{ss:fcvode_usage} for details).
  
\item \textcolor{gray}{\bf Problem solution}
  
\item {\bf {\cvbandpre} Optional outputs}
  
  Optional outputs specific to the {\spgmr}, {\spbcg}, or {\sptfqmr} solver are 
  listed in Table \ref{t:fcvode_out}.
  To obtain the optional outputs associated with the {\cvbandpre} module, make
  the following call:
  \index{FCVBPOPT@\texttt{FCVBPOPT}}
\begin{verbatim}
       CALL FCVBPOPT(LENRWBP, LENIWBP, NFEBP)
\end{verbatim}
  The arguments returned are as follows.
  \id{LENRWBP} is the length of real preconditioner work space, in \id{realtype}
  words. \id{LENIWBP} is the length of integer preconditioner work space, in
  integer words. \id{NFEBP} is the number of $f(t,y)$ evaluations (calls to
  \id{FCVFUN}) for difference-quotient banded Jacobian approximations.
  
\item \textcolor{gray}{\bf Memory deallocation}

  (The memory allocated for the {\fcvbp} module is deallocated automatically
  by \id{FCVFREE}.)

\end{Steps}
%%
\index{FCVODE@{\fcvode} interface module!interface to the {\cvbandpre} module|)}


%%==============================================================================
\section{Usage of the FCVBBD interface to CVBBDPRE}
%%==============================================================================
\index{FCVODE@{\fcvode} interface module!interface to the {\cvbbdpre} module|(}

The {\fcvbbd} interface sub-module is a package of {\C} functions which,
as part of the {\fcvode} interface module, support the use of the
{\cvode} solver with the parallel {\nvecp} module, and the combination of
the {\cvbbdpre} preconditioner module (see \S\ref{sss:cvbbdpre}) with
any of the Krylov iterative linear solvers.

The user-callable functions in this package, with the corresponding
{\cvode} and {\cvbbdpre} functions, are as follows: 
\begin{itemize}
\item \id{FCVBBDINIT}
  interfaces to \id{CVBBDPrecInit}.
\item \id{FCVBBDREINIT}
  interfaces to \id{CVBBDPrecReInit}.
\item \id{FCVBBDOPT}
  interfaces to {\cvbbdpre} optional output functions.
\end{itemize}

In addition to the {\F} right-hand side function \id{FCVFUN}, the
user-supplied functions used by this package, are listed below,
each with the corresponding interface function which calls it (and its
type within {\cvbbdpre} or {\cvode}):
\begin{center}
\begin{tabular}{l||l|l}
{\fcvbbd} routine      &  {\cvode} function & {\cvode} type of \\
({\F}, user-supplied)  &  ({\C}, interface) & interface function \\ \hline\hline
\id{FCVLOCFN}  & \id{FCVgloc}     & \id{CVLocalFn} \\
\id{FCVCOMMF}  & \id{FCVcfn}      & \id{CVCommFn} \\
\id{FCVJTIMES} & \id{FCVJtimes}   & \id{CVSpilsJacTimesVecFn} \\
\end{tabular}
\end{center}
As with the rest of the {\fcvode} routines, the names of all user-supplied routines 
here are fixed, in order to maximize portability for the resulting mixed-language
program.  Additionally, based on flags discussed above in \S\ref{sss:fcvroutines},
the names of the user-supplied routines are mapped to actual values
through a series of definitions in the header file \id{fcvbbd.h}.

The following is a summary of the usage of this module. Steps that are unchanged
from the main program described in \S\ref{ss:fcvode_usage} are grayed-out.

\index{User main program!FCVBBD@{\fcvbbd} usage}
\begin{Steps}
  
\item \textcolor{gray}{\bf Right-hand side specification}

\item \textcolor{gray}{\bf {\nvector} module initialization}

\item \textcolor{gray}{\bf Problem specification}

\item \textcolor{gray}{\bf Set optional inputs}

\item {\bf Linear solver specification}

  First, specify one of the {\cvspils} iterative linear solvers, by calling
  one of \id{FCVSPGMR}, \id{FCVSPBCG}, or \id{FCVSPTFQMR}.

  Then, to initialize the {\cvbbdpre} preconditioner, make the following call:
  \index{FCVBBDINIT@\texttt{FCVBBDINIT}}
\begin{verbatim}
       CALL FCVBBDINIT(NLOCAL, MUDQ, MLDQ, MU, ML, DQRELY, IER)
\end{verbatim}
  The arguments are as follows.
  \id{NLOCAL} is the local size of vectors on this processor.
  \id{MUDQ} and \id{MLDQ} are the upper and lower half-bandwidths to be used in 
  the computation of the local Jacobian blocks by difference quotients.
  These may be smaller than the true half-bandwidths of the
  Jacobian of the local block of $g$, when smaller values may
  provide greater efficiency.
  \id{MU} and \id{ML} are the upper and lower half-bandwidths of the band matrix
  that  is retained as an approximation of the local Jacobian block.
  These may be smaller than \id{MUDQ} and \id{MLDQ}.
  \id{DQRELY} is the relative increment factor in $y$ for difference quotients
  (optional).  A value of $0.0$ indicates the default, $\sqrt{\text{unit roundoff}}$.
  \id{IER} is a return completion flag.  A value of $0$ indicates success, while
  a value of $-1$ indicates that a memory failure occurred or that an input had
  an illegal value.
    
  Optionally, to specify that {\spgmr}, {\spbcg}, or {\sptfqmr} should use 
  the supplied \id{FCVJTIMES}, make the call
  \index{FCVSPILSSETJAC@\texttt{FCVSPILSSETJAC}}
\begin{verbatim}
       CALL FCVSPILSSETJAC(FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$ 
  (see step \ref{i:fcvode_lin_solv_spec} in \S\ref{ss:fcvode_usage} for details).


\item \textcolor{gray}{\bf Problem solution}
  
\item {\bf {\cvbbdpre} Optional outputs}
  
  Optional outputs specific to the {\spgmr}, {\spbcg}, or {\sptfqmr} solver are 
  listed in Table \ref{t:fcvode_out}.
  To obtain the optional outputs associated with the {\cvbbdpre} module, make
  the following call:
  \index{FCVBBDOPT@\texttt{FCVBBDOPT}}
\begin{verbatim}
       CALL FCVBBDOPT(LENRWBBD, LENIWBBD, NGEBBD)
\end{verbatim}
  The arguments returned are as follows.
  \id{LENRWBBD} is the length of real preconditioner work space, in \id{realtype}
  words. \id{LENIWBBD} is the length of integer preconditioner work space, in
  integer words.  These sizes are local to the current processor.
  \id{NGEBBD} is the number of $g(t,y)$ evaluations (calls to \id{FCVLOCFN}) so far.
  
\item {\bf Problem reinitialization}
  
  If a sequence of problems of the same size is being solved using the same
  linear solver ({\spgmr}, {\spbcg}, or {\sptfqmr})  in combination with the
  {\cvbbdpre} preconditioner, then the {\cvode} package can be re-initialized
  for the second and subsequent problems by calling \id{FCVREINIT},
  following which a call to \id{FCVBBDINIT} may or may not be needed.
  If the input arguments are the same, no \id{FCVBBDINIT} call is needed.
  If there is a change in input arguments other than \id{MU} or \id{ML},
  then the user program should make the call 
  \index{FCVBBDREINIT@\texttt{FCVBBDREINIT}}
\begin{verbatim}
       CALL FCVBBDREINIT(NLOCAL, MUDQ, MLDQ, DQRELY, IER)
\end{verbatim}
  This reinitializes the {\cvbbdpre} preconditioner, but without
  reallocating its memory.  The arguments of the \id{FCVBBDREINIT}
  routine have the same names and meanings as those of \id{FCVBBDINIT}.
  If the value of \id{MU} or \id{ML} is being changed, then a call to
  \id{FCVBBDINIT} must be made.  Finally, if there is a change in any of the
  linear solver inputs, then a call to \id{FCVSPGMR}, \id{FCVSPBCG}, or
  \id{FCVSPTFQMR} must also be made; in this case the linear solver memory is
  reallocated.
  
\item \textcolor{gray}{\bf Memory deallocation}

  (The memory allocated for the {\fcvbbd} module is deallocated automatically
  by \id{FCVFREE}.)

\index{FCVODE@{\fcvode} interface module!interface to the {\cvbbdpre} module|)}

\item {\bf User-supplied routines}

  The following two routines must be supplied for use with the {\cvbbdpre}
  module:
  \index{FCVGLOCFN@\texttt{FCVGLOCFN}}
\begin{verbatim}
      SUBROUTINE FCVGLOCFN (NLOC, T, YLOC, GLOC, IPAR, RPAR, IER)
      DIMENSION YLOC(*), GLOC(*), IPAR(*), RPAR(*)
\end{verbatim}
  This routine is to evaluate the function $g(t,y)$ approximating $f$
  (possibly identical to $f$), in terms of \id{T} $ = t$, and the array
  \id{YLOC} (of length \id{NLOC}), which is the sub-vector
  of $y$ local to this processor.  The resulting (local) sub-vector
  is to be stored in the array \id{GLOC}.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FCVMALLOC}.
  \id{IER} is an error return flag which should be set to $0$ if successful, 
  a positive value if a recoverable error occurred (in which case {\cvode} will 
  attempt to correct), or a negative value if \id{FCVGLOCFN} failed unrecoverably 
  (in which case the integration is halted).

  \index{FCVCOMMFN@\texttt{FCVCOMMFN}}
\begin{verbatim}
      SUBROUTINE FCVCOMMFN (NLOC, T, YLOC, IPAR, RPAR, IER)
      DIMENSION YLOC(*), IPAR(*), RPAR(*)
\end{verbatim}
  This routine is to perform the inter-processor communication necessary
  for the \id{FCVGLOCFN} routine.
  Each call to \id{FCVCOMMFN} is preceded by a call to the right-hand side
  routine \id{FCVFUN} with the same arguments \id{T} and \id{YLOC}.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FCVMALLOC}.
  \id{IER} is an error return flag (currently not used; set \id{IER=0}). 
  Thus \id{FCVCOMMFN} can omit any communications done by \id{FCVFUN} if
  relevant to the evaluation of \id{GLOC}.
  \id{IER} is an error return flag which should be set to $0$ if successful, 
  a positive value if a recoverable error occurred (in which case {\cvode} will 
  attempt to correct), or a negative value if \id{FCVCOMMFN} failed unrecoverably 
  (in which case the integration is halted).


  {\warn}The subroutine \id{FCVCOMMFN} must be supplied even if it is not needed 
  and must return \id{IER=0}.

  \index{FCVJTIMES@\texttt{FCVJTIMES}}
  Optionally, the user can supply a routine \id{FCVJTIMES} for the evaluation of
  Jacobian-vector products, as described above in step \ref{i:fcvode_lin_solv_spec}
  in \S\ref{ss:fcvode_usage}.

\end{Steps}

