%===================================================================================
\chapter{Using IDAS for Adjoint Sensitivity Analysis}\label{s:adjoint}
%===================================================================================

This chapter describes the use of {\idas} to compute sensitivities of derived 
functions using adjoint sensitivity analysis. As mentioned before, the adjoint
sensitivity module of {\idas} provides the infrastructure for integrating
backward in time any system of DAEs that depends on the solution of the original
IVP, by providing various interfaces to the main {\idas} integrator, as well 
as several supporting user-callable functions. For this reason, in the following
sections we refer to the {\em backward problem} and not to the 
{\em adjoint problem} when discussing details relevant to the DAEs that
are integrated backward in  time. The backward problem can be the adjoint problem
(\ref{e:adj_eqns}) or (\ref{e:adj1_eqns}), and
can be augmented with some quadrature differential equations.

{\idas} uses various constants for both input and output.  These are
defined as needed in this chapter, but for convenience are also listed
separately in Appendix \ref{c:constants}.

We begin with a brief overview, in the form of a skeleton user program.
Following that are detailed descriptions of the interface to the
various user-callable functions and of the user-supplied functions that were
not already described in Chapter \ref{s:simulation}.

%%
%%----------------------------------------------------------------------
%%----------------------------------------------------------------------
\section{A skeleton of the user's main program}
\label{ss:skeleton_adj}
%%---------------------------------------------------------------------
%%----------------------------------------------------------------------
%%

The following is a skeleton of the user's main program as an application of
{\idas}. The user program is to have these steps in the order indicated, 
unless otherwise noted. For the sake of brevity, we defer many of the details to 
the later sections.
As in \S\ref{ss:skeleton_sim}, most steps are independent of the {\nvector}
implementation used; where this is not the case, usage specifications are given for
the two implementations provided with {\idas}: steps marked {\p} correspond to 
{\nvecp}, steps marked {\omp} correspond to {\nvecopenmp}, steps
+marked {\pt} correspond to {\nvecpthreads}, while steps marked {\s}
correspond to {\nvecs}. 
Steps that are unchanged from the skeleton programs presented in
\S\ref{ss:skeleton_sim}, \S\ref{s:forward_usage}, and \S\ref{s:forward_quad_usage},
are grayed out.

\index{User main program!Adjoint sensitivity analysis}
\begin{Steps}

\item
  \textcolor{gray}{\bf Include necessary header files}
  
  The \id{idas.h} header file also defines additional types, constants, and
  function prototypes for the adjoint sensitivity module user-callable functions.
  In addition, the main program should include an {\nvector} 
  implementation header file (\id{nvector\_serial.h},
  \id{nvector\_openmp.h}, \id{nvector\_pthreads.h}, or \id{nvector\_parallel.h}
  for the implementations provided with {\idas}) and, if Newton iteration 
  was selected, the main header file of the desired linear solver module.

\item
  \textcolor{gray}{\bf {\p} Initialize MPI}

  \vspace{0.2in}\centerline{\bf Forward problem}

\item
  \textcolor{gray}{\bf Set problem dimensions for the forward problem}

\item
  \textcolor{gray}{\bf Set initial conditions for the forward problem}

\item
  \textcolor{gray}{\bf Create {\idas} object for the forward problem}

\item
  \textcolor{gray}{\bf Allocate internal memory for the forward problem}

\item
  \textcolor{gray}{\bf Specify integration tolerances for forward problem}

\item
  \textcolor{gray}{\bf Set optional inputs for the forward problem}

\item
  \textcolor{gray}{\bf Attach linear solver module for the forward problem}

\item
  \textcolor{gray}{\bf Set linear solver optional inputs for the forward problem}

\item
  \textcolor{gray}{\bf Initialize quadrature problem or problems for forward
   problems, using \id{IDAQuadInit} and/or \id{IDAQuadSensInit}.}

\item
  \textcolor{gray}{\bf Initialize forward sensitivity problem}

\item
  {\bf Allocate space for the adjoint computation}

  Call \Id{IDAAdjInit}\id{()} to allocate memory for the 
  combined forward-backward problem (see \S\ref{sss:idaadjinit} for details).
  This call requires \id{Nd}, the number of steps between two consecutive checkpoints.
  \Id{IDAAdjInit} also specifies the type of interpolation used 
  (see \S\ref{ss:checkpointing}).

\item
  {\bf Integrate forward problem}

  Call \Id{IDASolveF}, a wrapper for the {\idas} main integration
  function \id{IDASolve}, either in \Id{IDA\_NORMAL} mode to the time 
  \id{tout} or in \Id{IDA\_ONE\_STEP} mode inside a loop (if intermediate
  solutions of the forward problem are desired (see \S\ref{sss:idasolvef})).
  The final value of \id{tret} is then the maximum allowable value for
  the endpoint $T$ of the backward problem.

  \vspace{0.2in}\centerline{\bf Backward problem(s)}

 \item \label{i:back_start}
   {\bf Set problem dimensions for the backward problem}
   
   {\s, \omp, \pt} set \id{NB}, the number of variables in the backward problem \\
   {\p} set \id{NB} and \id{NBlocal}\\
   {\omp, \pt} set \id{num\_threads}

\item
  {\bf Set initial values for the backward problem}

  Set the endpoint time \id{tB0} $= T$ and the corresponding vectors \id{yB0}
  and \id{ypB0} at which the backward problem starts.

\item
  {\bf Create the backward problem}

  Call \Id{IDACreateB}, a wrapper for \id{IDACreate}, to create the
  {\idas} memory block for the new backward problem. Unlike \id{IDACreate}, 
  the function \id{IDACreateB} does not return a pointer to the newly created 
  memory block (see \S\ref{sss:idainitb}). Instead, this pointer is attached to 
  the internal adjoint memory  block (created by \id{IDAAdjInit}) and returns an
  identifier called \id{which} that the user must later specify in any actions on
  the newly created backward problem.

\item
  {\bf Allocate memory for the backward problem}

  Call \Id{IDAInitB} (or \Id{IDAInitBS}, when the backward problem depends on the
  forward sensitivities). The two functions are actually wrappers for \id{IDAInit} 
  and allocate internal memory, specify problem data, and initialize {\idas} 
  at \id{tB0} for the backward problem (see \S\ref{sss:idainitb}).

\item 
  {\bf Specify integration tolerances for backward problem}
  
  Call \id{IDASStolerancesB}\id{(...)} or \id{IDASVtolerancesB}\id{(...)}
  to specify a scalar relative tolerance and scalar absolute tolerance, or a
  scalar relative tolerance and a vector of absolute tolerances, respectively.
  The functions are wrappers for \id{IDASStolerances}\id{(...)} and
  \id{IDASVtolerances}\id{(...)} but they require an extra argument \id{which},
  the identifier of the backward problem returned by \id{IDACreateB}.
  See \S\ref{sss:idatolerances_b} for more information.


\item
  {\bf Set optional inputs for the backward problem}

  Call \id{IDASet*B} functions to change from their default values
  any optional inputs that control the behavior of {\idas}. Unlike
  their counterparts for the forward problem, these functions take an
  extra argument \id{which}, the identifier of the backward problem returned 
  by \id{IDACreateB} (see \S\ref{ss:optional_input_b}).


\item \label{i:lin_solverB}
  {\bf Attach linear solver module for the backward problem}

  Initialize the linear solver module 
  for the backward problem by calling the appropriate wrapper
  function: \id{IDADenseB}, \id{IDABandB}, \id{IDALapackDenseB}, \id{IDALapackBandB},
  \id{IDAKLUB}, \id{IDASuperLUMTB}, \id{IDASpgmrB}, \id{IDASpbcgB}, or
  \id{IDASptfqmrB} (see \S\ref{sss:lin_solv_b}).  
  Note that it is not required to use the same linear solver module for both the forward 
  and the backward problems; for example, the forward problem could be solved
  with the {\idadense} linear solver and the backward problem with {\idaspgmr}.

\item \label{i:quadB}
  {\bf Initialize quadrature calculation}

  If additional quadrature equations must be evaluated, 
  call \id{IDAQuadInitB} or \id{IDAQuadInitBS} (if quadrature depends also on the
  forward sensitivities) as shown in \S\ref{sss:idaquadinitb}. These functions are
  wrappers around \id{IDAQuadInit} and can be used to initialize and allocate 
  memory for quadrature integration. Optionally, call \id{IDASetQuad*B} functions 
  to change from their default values optional inputs that control the integration 
  of quadratures during the backward phase.

\item
  {\bf Integrate backward problem}

  Call \Id{IDASolveB}, a second wrapper around the {\idas} main integration
  function \id{IDASolve}, to integrate the backward problem from \id{tB0}
  (see \S\ref{sss:idasolveb}). This function can be called either in \id{IDA\_NORMAL}
  or \id{IDA\_ONE\_STEP} mode. Typically, \id{IDASolveB} will be called in \id{IDA\_NORMAL}
  mode with an end time equal to the initial time $t_0$ of the forward problem.

\item \label{i:back_end}
  {\bf Extract quadrature variables}

  If applicable, call \Id{IDAGetQuadB}, a wrapper around \id{IDAGetQuad},
  to extract the values of the quadrature variables at the time returned
  by the last call to \id{IDASolveB}.  See \S\ref{sss:quad_get_b}.

\item
  {\bf Deallocate memory}

  Upon completion of the backward integration, call all necessary deallocation
  functions. These include appropriate destructors for the vectors \id{y} and
  \id{yB}, a call to \id{IDAFree} to free the {\idas} memory block for the
  forward problem.  If additional forward integration(s) are to be done for
  this problem, a call to \id{IDAAdjFree} (see \S\ref{sss:idaadjinit}) may be
  made to free and deallocate the memory allocated for the backward problems.

\item
  \textcolor{gray}{\bf Finalize MPI}

  {\p} If {\mpi} was initialized by the user main program, call \id{MPI\_Finalize();}.

\end{Steps}

The above user interface to the adjoint sensitivity module in {\idas} was motivated by
the desire to keep it as close as possible in look and feel to the one for DAE IVP 
integration. Note that if steps (\ref{i:back_start})-(\ref{i:back_end}) are not present, 
a program with the above structure will have the same functionality as one described in
\S\ref{ss:skeleton_sim} for integration of DAEs, albeit with some overhead due to 
the checkpointing scheme.

If there are multiple backward problems associated with the same forward problem,
repeat steps (\ref{i:back_start})-(\ref{i:back_end}) above for each successive
backward problem.  In the process, each call to \id{IDACreateB} creates a new
value of the identifier \id{which}.

%%
%%-------------------------------------------------------------------------------
%%-------------------------------------------------------------------------------
\section{User-callable functions for adjoint sensitivity analysis}
%%-------------------------------------------------------------------------------
%%-------------------------------------------------------------------------------
%%

%%-------------------------------------------------------------------------------
\subsection{Adjoint sensitivity allocation and deallocation functions}
\label{sss:idaadjinit}
%%-------------------------------------------------------------------------------

After the setup phase for the forward problem, but before the call
to \id{IDASolveF}, memory for the combined forward-backward problem must be
allocated by a call to the function \id{IDAAdjInit}.
The form of the call to this function is
%%
%%
\ucfunction{IDAAdjInit}
{
  flag = IDAAdjInit(ida\_mem, Nd, interpType);
}
{
  The function \ID{IDAAdjInit} updates {\idas} memory block by allocating 
  the internal memory needed for backward integration.
  Space is allocated for the \id{Nd} $= N_d$ interpolation data points, and
  a linked list of checkpoints is initialized.
}
{
  \begin{args}[interpType]
  \item[ida\_mem] (\id{void *}) 
    is the pointer to the {\idas} memory block returned by a previous call
    to \id{IDACreate}.
  \item[Nd] (\id{long int}) 
    is the number of integration steps between two consecutive checkpoints.
  \item[interpType] (\id{int})
    specifies the type of interpolation used and can be \Id{IDA\_POLYNOMIAL}
    or \Id{IDA\_HERMITE}, indicating variable-degree polynomial and cubic Hermite
    interpolation, respectively (see \S\ref{ss:checkpointing}).
  \end{args}
}
{
   The return value \id{flag} (of type \id{int}) is one of:
   \begin{args}[IDA\_ILL\_INPUT]
   \item[\Id{IDA\_SUCCESS}] 
     \id{IDAAdjInit} was successful.
   \item[\Id{IDA\_MEM\_FAIL}]
     A memory allocation request has failed.
   \item[IDA\_MEM\_NULL] 
     \id{ida\_mem} was NULL.
   \item[\Id{IDA\_ILL\_INPUT}]
     One of the parameters was invalid: \id{Nd} was not positive or \id{interpType}
     is not one of the \id{IDA\_POLYNOMIAL} or \id{IDA\_HERMITE}.
   \end{args}
}
{
  The user must set \id{Nd} so that all data needed for interpolation of the 
  forward problem solution between two checkpoints fits in memory. \id{IDAAdjInit}
  attempts to allocate space for $(2$\id{Nd}$+3)$ variables of type \id{N\_Vector}.

  If an error occurred, \id{IDAAdjInit} also sends a message to the
  error handler function.
}
%%
%%
\ucfunction{IDAAdjReInit}
{
  flag = IDAAdjReInit(ida\_mem);
}
{
  The function \ID{IDAAdjReInit} reinitializes the {\idas} memory
  block for ASA, assuming that the number of steps between check
  points and the type of interpolation remain unchanged.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    is the pointer to the {\idas} memory block returned by a previous call to
    \id{IDACreate}.
  \end{args}
}
{
   The return value \id{flag} (of type \id{int}) is one of:
   \begin{args}[IDA\_MEM\_NULL]
   \item[\Id{IDA\_SUCCESS}] 
     \id{IDAAdjReInit} was successful.
   \item[IDA\_MEM\_NULL] 
     \id{ida\_mem} was NULL.
   \item[\Id{IDA\_NO\_ADJ}]
     The function \id{IDAAdjInit} was not previously called.
   \end{args}
}
{
  The list of check points (and associated memory) is deleted.

  The list of backward problems is kept. However, new backward problems can 
  be added to this list by calling \id{IDACreateB}. If a new list of backward
  problems is also needed, then free the adjoint memory (by calling
  \id{IDAAdjFree}) and reinitialize ASA with \id{IDAAdjInit}.

  The {\idas} memory for the forward and backward problems can be reinitialized
  separately by calling \id{IDAReInit} and \id{IDAReInitB}, respectively.
}



%%
%%
\ucfunction{IDAAdjFree}
{
  IDAAdjFree(ida\_mem);
}
{
  The function \ID{IDAAdjFree} frees the memory related to backward integration
  allocated by a previous call to \id{IDAAdjInit}.
}
{
  The only argument is the {\idas} memory block pointer returned by a previous call 
  to \id{IDACreate}.
}
{
  The function \id{IDAAdjFree} has no return value.
}
{
  This function frees all memory allocated by \id{IDAAdjInit}. This
  includes workspace memory, the linked list of checkpoints, memory
  for the interpolation data, as well as the {\idas} memory for the
  backward integration phase.

  In general, \id{IDAAdjFree} need not be called by the user as it is
  invoked automatically by \id{IDAFree}.
}
%%
%%


%%-------------------------------------------------------------------------------
\subsection{Adjoint sensitivity optional input}

At any time during the integration of the forward problem, the user
can disable the checkpointing of the forward sensitivities by calling
the following function:

\ucfunction{IDAAdjSetNoSensi}
{
  flag = IDAAdjSetNoSensi(ida\_mem);
}
{
  The function \ID{IDAAdjSetNoSensi} instructs \id{IDASolveF} not
  to save checkpointing data for forward sensitivities any more.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas}  memory block.
  \end{args}
}
{
  The return \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDA\_MEM\_FAIL]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDACreateB} was successful.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \end{args}
}
{}
%%-------------------------------------------------------------------------------


%%---------------------------------------------------------------------
\subsection{Forward integration function}
\label{sss:idasolvef}
%%---------------------------------------------------------------------

The function \ID{IDASolveF} is very similar to the {\idas} function \id{IDASolve}
(see \S\ref{sss:idasolve}) in that it integrates the solution of the forward
problem and returns the solution $(y,\dot{y})$. At the same time, however, 
\id{IDASolveF} stores checkpoint data every \id{Nd} integration steps. \id{IDASolveF} 
can be called repeatedly by the user.
%%
The call to this function has the form
%%
\ucfunction{IDASolveF}
{
  flag = IDASolveF(ida\_mem, tout, \&tret, yret, ypret, itask, \&ncheck);
}
{
  The function \ID{IDASolveF} integrates the forward problem over an interval in $t$
  and saves checkpointing data.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[tout] (\id{realtype})
    the next time at which a computed solution is desired.
  \item[tret] (\id{realtype})
    the time reached by the solver (output).
  \item[yret] (\id{N\_Vector})
    the computed solution vector $y$.
  \item[ypret] (\id{N\_Vector})
    the computed solution vector $\dot{y}$.
  \item[itask] (\id{int})
    \index{itask@\texttt{itask}}
    \index{output mode}
    a flag indicating the job of the solver for the next step. 
    The \Id{IDA\_NORMAL} task is to have the solver take internal steps until   
    it has reached or just passed the user-specified \id{tout}
    parameter. The solver then interpolates in order to   
    return an approximate value of $y($\id{tout}$)$ and $\dot{y}($\id{tout}$)$. 
    The \Id{IDA\_ONE\_STEP} option tells the solver to take just one internal step  
    and return the solution at the point reached by that step. 
  \item[ncheck] (\id{int})
    the number of (internal) checkpoints stored so far.
  \end{args}
}
{
  On return, \id{IDASolveF} returns vectors \id{yret}, \id{ypret} and a corresponding 
  independent variable value $t =$ \id{tret}, such that \id{yret} is the computed 
  value of $y(t)$ and \id{ypret} the value of $\dot{y}(t)$. Additionally, it returns 
  in \id{ncheck} the number of internal checkpoints saved; the total number of
  checkpoint intervals is \id{ncheck}$ + 1$.
  The return value \id{flag} (of type \id{int}) will be one of the following.
  For more details see \S\ref{sss:idasolve}.
  \begin{args}[IDA\_TOO\_MUCH\_WORK]
  \item[\Id{IDA\_SUCCESS}]
    \id{IDASolveF} succeeded.
  \item[\Id{IDA\_TSTOP\_RETURN}]
    \id{IDASolveF} succeeded by reaching the optional stopping point.
  \item[\Id{IDA\_NO\_MALLOC}]
    The function \id{IDAInit} has not been previously called.
  \item[\Id{IDA\_ILL\_INPUT}]
    One of the inputs to \id{IDASolveF} is illegal.
  \item[\Id{IDA\_TOO\_MUCH\_WORK}] 
    The solver took \id{mxstep} internal steps but could not reach \id{tout}. 
  \item[\Id{IDA\_TOO\_MUCH\_ACC}] 
    The solver could not satisfy the accuracy demanded by the user for some 
    internal step.
  \item[\Id{IDA\_ERR\_FAILURE}]
    Error test failures occurred too many times during one 
    internal time step or occurred with $|h| = h_{min}$.
  \item[\Id{IDA\_CONV\_FAILURE}] 
    Convergence test failures occurred too many times during 
    one internal time step or occurred with $|h| = h_{min}$.             
  \item[\Id{IDA\_LSETUP\_FAIL}] 
    The linear solver's setup function failed in an unrecoverable manner.
  \item[\Id{IDA\_LSOLVE\_FAIL}] 
    The linear solver's solve function failed in an unrecoverable manner.
  \item[\Id{IDA\_NO\_ADJ}]
     The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDA\_MEM\_FAIL}]
    A memory allocation request has failed (in an attempt to allocate space
    for a new checkpoint).
  \end{args} 
}
{
  All failure return values are negative and therefore a test \id{flag}$< 0$
  will trap all \id{IDASolveF} failures.

  At this time, \id{IDASolveF} stores checkpoint information in memory
  only. Future versions will provide for a safeguard option of dumping checkpoint
  data into a temporary file as needed. The data stored at each checkpoint is basically
  a snapshot of the {\idas} internal memory block and contains enough information
  to restart the integration from that time and to proceed with the same step size and
  method order sequence as during the forward integration.
  
  In addition, \id{IDASolveF} also stores interpolation data between consecutive checkpoints
  so that, at the end of this first forward integration phase, interpolation information
  is already available from the last checkpoint forward. In particular,
  if no checkpoints were necessary, there is no need for the second forward integration phase.

  {\warn}It is illegal to change the integration tolerances between consecutive calls
  to \id{IDASolveF}, as this information is not captured in the checkpoint data.
}  

%%---------------------------------------------------------------------
\subsection{Backward problem initialization functions}
\label{sss:idainitb}
%%---------------------------------------------------------------------

The functions \id{IDACreateB} and \id{IDAInitB} (or \id{IDAInitBS}) must be 
called in the order listed. They instantiate an {\idas} solver object, provide problem 
and solution specifications, and allocate internal memory for the backward problem.
%%
%%
\ucfunction{IDACreateB}
{
  flag = IDACreateB(ida\_mem, \&which);
}
{
  The function \ID{IDACreateB} instantiates an {\idas} solver object for the
  backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block returned by \id{IDACreate}.
  \item[which] (\id{int})
    contains the identifier assigned by {\idas} for the newly created backward 
    problem. Any call to \id{IDA*B} functions requires such an identifier.
  \end{args}
}
{
   The return \id{flag} (of type \id{int}) is one of:
   \begin{args}[IDA\_MEM\_FAIL]
   \item[\Id{IDA\_SUCCESS}]
     The call to \id{IDACreateB} was successful.
   \item[\Id{IDA\_MEM\_NULL}]
     The \id{ida\_mem} was \id{NULL}.
   \item[\Id{IDA\_NO\_ADJ}]
     The function \id{IDAAdjInit} has not been previously called.
   \item[\Id{IDA\_MEM\_FAIL}]
     A memory allocation request has failed.
   \end{args}
}
{}

There are two initialization functions for the backward problem -- one for
the case when the backward problem does not depend on the forward
sensitivities, and one for the case when it does.  These two functions
are described next.

The function \id{IDAInitB} initializes the backward problem when it does not
depend on the forward sensitivities.  It is essentially wrapper for \id{IDAInit}
with some particularization for backward integration, as described below.

\ucfunction{IDAInitB}
{
  flag = IDAInitB(ida\_mem, which, resB, tB0, yB0, ypB0);
}
{
  The function \ID{IDAInitB} provides problem specification, allocates internal memory, 
  and initializes the backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block returned by \id{IDACreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[resB] (\Id{IDAResFnB})
    is the {\C} function which computes $fB$, the residual of the 
    backward DAE problem. This function has the form 
    \id{resB(t, y, yp, yB, ypB, resvalB, user\_dataB)} (for full details see
    \S\ref{ss:DAEres_b}).
  \item[tB0] (\id{realtype})
    specifies the endpoint $T$ where final conditions are provided for the backward
    problem, normally equal to the endpoint of the forward integration.
  \item[yB0] (\id{N\_Vector})
    is the initial value (at $t =$ \id{tB0}) of the backward solution.
  \item[ypB0] (\id{N\_Vector})
    is the initial derivative value (at $t =$ \id{tB0}) of the backward solution.
  \end{args}
}
{
  The return \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDAInitB} was successful.
  \item[\Id{IDA\_NO\_MALLOC}]
    The function \id{IDAInit} has not been previously called.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDA\_BAD\_TB0}]
    The final time \id{tB0} was outside the interval over which the forward problem
    was solved.
  \item[\Id{IDA\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier, or one
    of \id{yB0}, \id{ypB0}, \id{resB} was \id{NULL}.
  \end{args}
}
{
  The memory allocated by \id{IDAInitB} is deallocated by the function 
  \id{IDAAdjFree}.
}

For the case when backward problem also depends on the forward sensitivities, user
must call \id{IDAInitBS} instead of \id{IDAInitB}. Only the third argument of each
function differs between these functions.

\ucfunction{IDAInitBS}
{
  flag = IDAInitBS(ida\_mem, which, resBS, tB0, yB0, ypB0);
}
{
  The function \ID{IDAInitBS} provides problem specification, allocates internal memory, 
  and initializes the backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block returned by \id{IDACreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[resBS] (\Id{IDAResFnBS})
    is the {\C} function which computes $fB$, the residual or the 
    backward DAE problem. This function has the form 
    \id{resBS(t, y, yp, yS, ypS, yB, ypB, resvalB, user\_dataB)} 
    (for full details see \S\ref{ss:DAEres_bs}).
  \item[tB0] (\id{realtype})
    specifies the endpoint $T$ where final conditions are provided for the 
    backward problem.
  \item[yB0] (\id{N\_Vector})
    is the initial value (at $t =$ \id{tB0}) of the backward solution. 
  \item[ypB0] (\id{N\_Vector})
    is the initial derivative value (at $t =$ \id{tB0}) of the backward solution. 
  \end{args}
}
{
  The return \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDAInitB} was successful.
  \item[\Id{IDA\_NO\_MALLOC}]
    The function \id{IDAInit} has not been previously called.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDA\_BAD\_TB0}]
    The final time \id{tB0} was outside the interval over which the forward problem
    was solved.
  \item[\Id{IDA\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier, or one
    of \id{yB0}, \id{ypB0}, \id{resB} was \id{NULL}, or sensitivities were not
    active during the forward integration.
  \end{args}
}
{
  The memory allocated by \id{IDAInitBS} is deallocated by the function 
  \id{IDAAdjFree}.
  
}

The function \id{IDAReInitB} reinitializes {\idas} for the solution of a series
of backward problems, each identified by a value of the parameter \id{which}.
\id{IDAReInitB} is essentially a wrapper for \id{IDAReInit}, and so all details
given for \id{IDAReInit} in \S\ref{sss:idareinit} apply.\index{reinitialization}
Also, \id{IDAReInitB} can be called to reinitialize a backward problem even if it
has been initialized with the sensitivity-dependent version \id{IDAInitBS}.
The call to the \id{IDAReInitB} function has the form
%%
%%
\ucfunction{IDAReInitB}
{
  flag = IDAReInitB(ida\_mem, which, tB0, yB0, ypB0)
}
{
  The function \ID{IDAReInitB} reinitializes {\idas} the backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to {\idas} memory block returned by \id{IDACreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[tB0] (\id{realtype})
    specifies the endpoint $T$ where final conditions are provided for the 
    backward problem.
  \item[yB0] (\id{N\_Vector})
    is the initial value (at $t =$ \id{tB0}) of the backward solution. 
  \item[ypB0] (\id{N\_Vector})
    is the initial derivative value (at $t =$ \id{tB0}) of the backward solution. 
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDAReInitB} was successful.
  \item[\Id{IDA\_NO\_MALLOC}]
    The function \id{IDAInit} has not been previously called.
  \item[\Id{IDA\_MEM\_NULL}] 
    The \id{ida\_mem} memory block pointer was \id{NULL}.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDA\_BAD\_TB0}]
    The final time \id{tB0} is outside the interval over which the forward problem
    was solved.
  \item[\Id{IDA\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier, or one
    of \id{yB0}, \id{ypB0} was \id{NULL}.
  \end{args}
}
{}

%%
%%==============================================================================
\subsection{Tolerance specification functions for backward problem}
\label{sss:idatolerances_b}
%%==============================================================================
%%
One of the following two functions must be called to specify the integration 
tolerances for the backward problem. Note that this call must be made after the 
call to \id{IDAInitB} or \id{IDAInitBS}.
%%
\ucfunction{IDASStolerancesB}
{
  flag = IDASStolerances(ida\_mem, which, reltolB, abstolB);
}
{
  The function \ID{IDASStolerancesB} specifies scalar relative and absolute
  tolerances.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block returned by \id{IDACreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[reltolB] (\id{realtype})
    is the scalar relative error tolerance.
  \item[abstolB] (\id{realtype})
    is the scalar absolute error tolerance.
  \end{args}
}
{
  The return \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDASStolerancesB} was successful.
  \item[\Id{IDA\_MEM\_NULL}] 
    The {\idas} memory block was not initialized through a previous call to
    \id{IDACreate}.
  \item[\Id{IDA\_NO\_MALLOC}] 
    The allocation function \id{IDAInit} has not been called.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDA\_ILL\_INPUT}] 
    One of the input tolerances was negative.
  \end{args}
}
{}
%%
%%
\ucfunction{IDASVtolerancesB}
{
  flag = IDASVtolerancesB(ida\_mem, which, reltolB, abstolB);
}
{
  The function \ID{IDASVtolerancesB} specifies scalar relative tolerance and
  vector absolute tolerances.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block returned by \id{IDACreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[reltol] (\id{realtype})
    is the scalar relative error tolerance.
  \item[abstol] (\id{N\_Vector})
    is the vector of absolute error tolerances.
  \end{args}
}
{
  The return \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDASVtolerancesB} was successful.
  \item[\Id{IDA\_MEM\_NULL}] 
    The {\idas} memory block was not initialized through a previous call to
    \id{IDACreate}.
  \item[\Id{IDA\_NO\_MALLOC}] 
    The allocation function \id{IDAInit} has not been called.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDA\_ILL\_INPUT}] 
    The relative error tolerance was negative or the absolute tolerance
    had a negative component.
  \end{args}
}
{
  This choice of tolerances is important when the absolute error tolerance needs to
  be different for each component of the DAE state vector $y$.
}
%%

%%---------------------------------------------------------------------
\subsection{Linear solver initialization functions for backward problem}
\label{sss:lin_solv_b}
%%---------------------------------------------------------------------

\index{IDAS@{\idas} linear solvers!usage with adjoint module|(}
All {\idas} linear solver modules available for forward problems
provide additional specification functions for backward problems.  The
initialization functions described in \S\ref{sss:lin_solv_init} cannot
be directly used since the optional user-defined Jacobian-related
functions have different prototypes for the backward problem than for
the forward problem (see \S\ref{ss:user_fct_adj}).
\index{IDAS@{\idas} linear solvers!usage with adjoint module|)} 

The following wrapper functions can be used to initialize one of the linear
solver modules for the backward problem. Their arguments are identical to those
of the functions in \S\ref{sss:lin_solv_init} with the exception of the additional
second argument, \id{which}, the identifier of the backward problem.
\begin{verbatim}
  flag = IDADenseB(ida_mem, which, nB);
  flag = IDABandB(ida_mem, which, nB, mupperB, mlowerB);
  flag = IDALapackDenseB(ida_mem, which, nB);
  flag = IDALapackBandB(ida_mem, which, nB, mupperB, mlowerB);
  flag = IDAKLUB(ida_mem, which, nB, nnzB);
  flag = IDASuperLUMTB(ida_mem, num_threads, which, nB, nnzB);
  flag = IDASpgmrB(ida_mem, which, maxlB);
  flag = IDASpbcgB(ida_mem, which, maxlB);
  flag = IDASptfqmrB(ida_mem, which, maxlB);
\end{verbatim}

Their return value \id{flag} (of type \id{int}) can have any of the return values of their counterparts.
%%
If the \id{ida\_mem} argument was \id{NULL}, 
\id{flag} will be \id{IDADLS\_MEM\_NULL}, \id{IDASLS\_MEM\_NULL} or
\id{IDASPILS\_MEM\_NULL}. 
%%
Also, if \id{which} is not a valid identifier, the functions will return 
\id{IDADLS\_ILL\_INPUT}, \id{IDASLS\_ILL\_INPUT} or \id{IDASPILS\_ILL\_INPUT}.


%%---------------------------------------------------------------------
\subsection{Initial condition calculation functions for backward problem}
\label{sss:idacalcicB}
%%---------------------------------------------------------------------

{\idas} provides support for calculation of consistent initial 
conditions for certain backward index-one problems of semi-implicit form through
the functions \Id{IDACalcICB} and \Id{IDACalcICBS}. Calling them is 
optional. It is only necessary when the initial conditions do not satisfy
the adjoint system. 

The above functions provide the same functionality for backward problems as 
\id{IDACalcIC} with parameter \id{icopt} =  \id{IDA\_YA\_YDP\_INIT} 
provides for forward problems (see \S\ref{ss:idacalcic}): compute the 
algebraic components of $yB$ and differential  components of $\dot{y}B$, given 
the differential components of $yB$.  They require that the \id{IDASetIdB}
was previously called to specify the differential and algebraic components.


Both functions require forward solutions at the final time \id{tB0}.
\id{IDACalcICBS} also needs forward sensitivities at the final time \id{tB0}.

\ucfunction{IDACalcICB}
{
  flag = IDACalcICB(ida\_mem, which, tBout1, N\_Vector yfin, N\_Vector ypfin);
}
{
  The function \ID{IDACalcICB} corrects the initial values \id{yB0} and \id{ypB0} at
  time \id{tB0} for the backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    is the identifier of the backward problem.
  \item[tBout1] (\id{realtype})
    is the first value of $t$ at which a solution will be requested (from
    \id{IDASolveB}). This value is needed here only to determine the direction of
    integration and rough scale in the independent variable $t$.   
  \item[yfin] (\id{N\_Vector})
    the forward solution at the final time \id{tB0}.
  \item[ypfin] (\id{N\_Vector})
    the forward solution derivative at the final time \id{tB0}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) can be any that is returned by 
  \id{IDACalcIC} (see \S\ref{ss:idacalcic}). However \id{IDACalcICB} can also 
  return one of the following:

  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_NO\_ADJ}]
    \id{IDAAdjInit} has not been previously called.
  \item[\id{IDA\_ILL\_INPUT}]
    Parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  All failure return values are negative and therefore a test \id{flag} $< 0$
  will trap all \id{IDACalcICB} failures.

  Note that \id{IDACalcICB} will correct the values of $yB(tB_0)$ and 
  $\dot{y}B(tB_0)$ which were specified in the previous call to \id{IDAInitB} 
  or \id{IDAReInitB}. To obtain the corrected values, call 
  \id{IDAGetconsistentICB} (see \S\ref{sss:optout_iccalcB}).
}

In the case where the backward problem also depends on the forward sensitivities, 
user must call the following function to correct the initial conditions:

\ucfunction{IDACalcICBS}
{
  \begin{tabular}[t]{@{}r@{}l@{}}
  flag = IDACalcICBS(&ida\_mem, which, tBout1, N\_Vector yfin, N\_Vector ypfin, \\
                     &N\_Vector ySfin, N\_Vector ypSfin);
  \end{tabular}
}
{
  The function \ID{IDACalcICBS} corrects the initial values \id{yB0} and \id{ypB0} at
  time \id{tB0} for the backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    is the identifier of the backward problem.
  \item[tBout1] (\id{realtype})
    is the first value of $t$ at which a solution will be requested (from
    \id{IDASolveB}).This value is needed here only to determine the direction of
    integration and rough scale in the independent variable $t$.   
  \item[yfin] (\id{N\_Vector})
    the forward solution at the final time \id{tB0}.
  \item[ypfin] (\id{N\_Vector})
    the forward solution derivative at the final time \id{tB0}.
  \item[ySfin]  (\id{N\_Vector *})
    a pointer to an array of \id{Ns} vectors containing the sensitivities of
    the forward solution at the final time \id{tB0}.
  \item[ypSfin]  (\id{N\_Vector *})
    a pointer to an array of \id{Ns} vectors containing the derivatives of
    the forward solution sensitivities at the final time \id{tB0}.

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) can be any that is returned by 
  \id{IDACalcIC} (see \S\ref{ss:idacalcic}). However \id{IDACalcICBS} can also 
  return one of the following:

  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_NO\_ADJ}]
    \id{IDAAdjInit} has not been previously called.
  \item[\id{IDA\_ILL\_INPUT}]
    Parameter \id{which} represented an invalid identifier, sensitivities were
    not active during forward integration, or \id{IDAInitBS} (or \id{IDAReInitBS})
    has not been previously called.
  \end{args} 
}
{
  All failure return values are negative and therefore a test \id{flag} $< 0$
  will trap all \id{IDACalcICBS} failures.

  Note that \id{IDACalcICBS} will correct the values of $yB(tB_0)$ and 
  $\dot{y}B(tB_0)$ which were specified in the previous call to \id{IDAInitBS} 
  or \id{IDAReInitBS}. To obtain the corrected values, call 
  \id{IDAGetConsistentICB} (see \S\ref{sss:optout_iccalcB}).
}



%%---------------------------------------------------------------------
\subsection{Backward integration function}
\label{sss:idasolveb}
%%---------------------------------------------------------------------

The function \ID{IDASolveB} performs the integration of the backward problem.
It is essentially a wrapper for the {\idas} main integration function 
\id{IDASolve} and, in the case in which checkpoints were needed, it evolves 
the solution of the backward problem through a sequence of forward-backward 
integration pairs between consecutive checkpoints. 
In each pair, the first run integrates the original IVP forward in time and
stores interpolation data; the second run integrates the backward problem 
backward in time and performs the required interpolation to provide
the solution of the IVP to the backward problem.

The function \id{IDASolveB} does not return the solution \id{yB}
itself.  To obtain that, call the function \id{IDAGetB}, which is
also described below.

The call to \id{IDASolveB} has the form
%%
\ucfunction{IDASolveB}
{
  flag = IDASolveB(ida\_mem, tBout, itaskB);
}
{
  The function \ID{IDASolveB} integrates the backward DAE problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory returned by \id{IDACreate}.
  \item[tBout] (\id{realtype})
    the next time at which a computed solution is desired.
  \item[itaskB] (\id{int})
    \index{output mode}
    a flag indicating the job of the solver for the next step. 
    The \Id{IDA\_NORMAL} task is to have the solver take internal steps until   
    it has reached or just passed the user-specified value \id{tBout}.
    The solver then interpolates in order to   
    return an approximate value of $yB($\id{tBout}$)$. 
    The \Id{IDA\_ONE\_STEP} option tells the solver to take just one internal
    step in the direction of \id{tBout} and return. 
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following.
  For more details see \S\ref{sss:idasolve}.
  \begin{args}[IDA\_TOO\_MUCH\_WORK]
  \item[\Id{IDA\_SUCCESS}]
    \id{IDASolveB} succeeded.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDA\_NO\_BCK}]
    No backward problem has been added to the list of backward problems by
    a call to \id{IDACreateB}
  \item[\Id{IDA\_NO\_FWD}]
    The function \id{IDASolveF} has not been previously called.
  \item[\Id{IDA\_ILL\_INPUT}]
    One of the inputs to \id{IDASolveB} is illegal.
  \item[\Id{IDA\_BAD\_ITASK}]
    The \id{itaskB} argument has an illegal value.
  \item[\Id{IDA\_TOO\_MUCH\_WORK}] 
    The solver took \id{mxstep} internal steps but could not reach \id{tBout}. 
  \item[\Id{IDA\_TOO\_MUCH\_ACC}] 
    The solver could not satisfy the accuracy demanded by the user for some 
    internal step.
  \item[\Id{IDA\_ERR\_FAILURE}]
    Error test failures occurred too many times during one internal time step.
  \item[\Id{IDA\_CONV\_FAILURE}] 
    Convergence test failures occurred too many times during one internal time step.
  \item[\Id{IDA\_LSETUP\_FAIL}] 
    The linear solver's setup function failed in an unrecoverable manner.
  \item[\Id{IDA\_SOLVE\_FAIL}] 
    The linear solver's solve function failed in an unrecoverable manner.
  \item[\Id{IDA\_BCKMEM\_NULL}]
    The {\idas} memory for the backward problem was not created with
    a call to \id{IDACreateB}.
  \item[\Id{IDA\_BAD\_TBOUT}]
    The desired output time \id{tBout} is outside the interval over which the 
    forward problem was solved.
  \item[\Id{IDA\_REIFWD\_FAIL}]
    Reinitialization of the forward problem failed at the first checkpoint
    (corresponding to the initial time of the forward problem).
  \item[\Id{IDA\_FWD\_FAIL}]
    An error occurred during the integration of the forward problem.
  \end{args} 
}
{
  All failure return values are negative and therefore a test \id{flag}$< 0$
  will trap all \id{IDASolveB} failures.

  In the case of multiple checkpoints and multiple backward problems, a given
  call to \id{IDASolveB} in \id{IDA\_ONE\_STEP} mode may not advance every problem
  one step, depending on the relative locations of the current times reached.
  But repeated calls will eventually advance all problems to \id{tBout}.
}
%%
%%
To obtain the solution \id{yB} to the backward problem, call the function
\id{IDAGetB} as follows:
%%
\ucfunction{IDAGetB}
{
  flag = IDAGetB(ida\_mem, which, \&tret, yB, ypB);
}
{
  The function \ID{IDAGetB} provides the solution \id{yB} of the backward DAE
  problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory returned by \id{IDACreate}.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[tret] (\id{realtype})
    the time reached by the solver (output).
  \item[yB] (\id{N\_Vector})
    the backward solution at time \id{tret}.
  \item[ypB] (\id{N\_Vector})
    the backward solution derivative at time \id{tret}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following.
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}] 
    \id{IDAGetB} was successful.
  \item[\Id{IDA\_MEM\_NULL}] 
    \id{ida\_mem} is \id{NULL}.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
   \item[\Id{IDA\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args} 
}
{
  {\warn} The user must allocate space for \id{yB} and \id{ypB}.
}


%%---------------------------------------------------------------------
\subsection{Optional input functions for the backward problem}
\label{ss:optional_input_b}
%%---------------------------------------------------------------------
%%
\subsubsection{Main solver optional input functions}
\index{optional input!backward solver|(}

The adjoint module in {\idas} provides wrappers for most of the optional 
input functions defined in \S\ref{sss:optin_main}. The only difference is 
that the user must specify the identifier \id{which} of the backward problem 
within the list managed by {\idas}. 

The optional input functions defined for the backward problem are:
\begin{verbatim}
  flag = IDASetUserDataB(ida_mem, which, user_dataB);
  flag = IDASetMaxOrdB(ida_mem, which, maxordB);
  flag = IDASetMaxNumStepsB(ida_mem, which, mxstepsB);
  flag = IDASetInitStepB(ida_mem, which, hinB)
  flag = IDASetMaxStepB(ida_mem, which, hmaxB);
  flag = IDASetSuppressAlgB(ida_mem, which, suppressalgB);
  flag = IDASetIdB(ida_mem, which, idB);
  flag = IDASetConstraintsB(ida_mem, which, constraintsB);
\end{verbatim}
Their return value \id{flag} (of type \id{int}) can have any of the return values 
of their counterparts, but it can also be \Id{IDA\_NO\_ADJ} if \id{IDAAdjInit} 
has not been called, or \Id{IDA\_ILL\_INPUT} if \id{which} was an invalid identifier. 

\index{optional input!backward solver|)}

\subsubsection{Dense linear solver}
\index{optional input!dense linear solver|(}
\index{IDADENSE@{\idadense} linear solver!optional input|(}
Optional inputs for the {\idadense} linear solver module can be set for the backward
problem through the following two functions:
%%
\index{Jacobian approximation function!dense!user-supplied (backward)}
\ucfunction{IDADlsSetDenseJacFnB}
{
  flag = IDADlsSetDenseJacFnB(ida\_mem, which, jacB);
}
{
  The function \ID{IDADlsSetDenseJacFnB} specifies the dense Jacobian
  approximation function to be used for the backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory returned by \id{IDACreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[jacB] (\id{IDADlsDenseJacFnB})
    user-defined dense Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDADLS\_ILL\_INPUT]
  \item[\Id{IDADLS\_SUCCESS}] 
    \id{IDADlsSetDenseJacFnB} succeeded.
  \item[\Id{IDADLS\_MEM\_NULL}]
    The \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDADLS\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDADLS\_LMEM\_NULL}]
    The linear solver has not been initialized with a call to \id{IDADenseB}
    or \id{IDALapackDenseB}.
  \item[\Id{IDADLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{IDADlsDenseJacFnB} is described in \S\ref{ss:densejac_b}.
}

\index{IDADENSE@{\idadense} linear solver!optional input|)}
\index{optional input!dense linear solver|)}

\index{Jacobian approximation function!dense!user-supplied (backward)}
\ucfunction{IDADlsSetDenseJacFnBS}
{
  flag = IDADlsSetDenseJacFnBS(ida\_mem, which, jacBS);
}
{
  The function \ID{IDADlsSetDenseJacFnBS} specifies the dense Jacobian
  approximation function to be used for the backward problem, in the case
  where the backward problem depends on the forward sensitivities.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory returned by \id{IDACreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[jacBS] (\id{IDADlsDenseJacFnBS})
    user-defined dense Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDADLS\_ILL\_INPUT]
  \item[\Id{IDADLS\_SUCCESS}] 
    \id{IDADlsSetDenseJacFnBS} succeeded.
  \item[\Id{IDADLS\_MEM\_NULL}]
    The \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDADLS\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDADLS\_LMEM\_NULL}]
    The linear solver has not been initialized with a call to \id{IDADenseB}
    or \id{IDALapackDenseB}.
  \item[\Id{IDADLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{IDADlsDenseJacFnBS} is described in \S\ref{ss:densejac_b}.
}
\index{IDADENSE@{\idadense} linear solver!optional input|)}
\index{optional input!dense linear solver|)}


\subsubsection{Band linear solver}
\index{optional input!band linear solver|(}
\index{IDABAND@{\idaband} linear solver!optional input|(}
Optional inputs for the {\idaband} linear solver module can be set for the backward
problem through the following two functions:
%%
\index{Jacobian approximation function!band!user-supplied (backward)}
\ucfunction{IDADlsSetBandJacFnB}
{
  flag = IDADlsSetBandJacFnB(ida\_mem, which, jacB);
}
{
  The function \ID{IDADlsSetBandJacFnB} specifies the banded Jacobian
  approximation function to be used for the backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory returned by \id{IDACreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[jacB] (\id{IDADlsBandJacFnB})
    user-defined banded Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDADLS\_ILL\_INPUT]
  \item[\Id{IDADLS\_SUCCESS}] 
    \id{IDADlsSetBandJacFnB} succeeded.
  \item[\Id{IDADLS\_MEM\_NULL}]
    The \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDADLS\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDADLS\_LMEM\_NULL}]
    The linear solver has not been initialized with a call to \id{IDABandB} or
    \id{IDALapackBandB}.
  \item[\Id{IDADLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{IDADlsBandJacFnB} is described in \S\ref{ss:bandjac_b}.
}
\index{IDABAND@{\idaband} linear solver!optional input|)}
\index{optional input!band linear solver|)}

\index{Jacobian approximation function!band!user-supplied (backward)}
\ucfunction{IDADlsSetBandJacFnBS}
{
  flag = IDADlsSetBandJacFnBS(ida\_mem, which, jacBS);
}
{
  The function \ID{IDADlsSetBandJacFnBS} specifies the banded Jacobian
  approximation function to be used for the backward problem, in the case
  where the backward problem depends on the forward sensitivities.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory returned by \id{IDACreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[jacBS] (\id{IDADlsBandJacFnBS})
    user-defined banded Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDADLS\_ILL\_INPUT]
  \item[\Id{IDADLS\_SUCCESS}] 
    \id{IDADlsSetBandJacFnBS} succeeded.
  \item[\Id{IDADLS\_MEM\_NULL}]
    The \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDADLS\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDADLS\_LMEM\_NULL}]
    The linear solver has not been initialized with a call to \id{IDABandB} or
    \id{IDALapackBandB}.
  \item[\Id{IDADLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{IDADlsBandJacFnBS} is described in \S\ref{ss:bandjac_b}.
}
\index{IDABAND@{\idaband} linear solver!optional input|)}
\index{optional input!band linear solver|)}


\subsubsection{Sparse linear solvers}
\index{optional input!sparse linear solver|(}
\index{IDAKLU@{\idaklu} linear solver!optional input|(}
\index{IDASUPERLUMT@{\idasuperlumt} linear solver!optional input|(}
Optional inputs for the {\idaklu} and {\idasuperlumt} linear solver
modules can be set for the backward problem through the following two
functions: 
%%
\index{Jacobian approximation function!sparse!user-supplied (backward)}
\ucfunction{IDASlsSetSparseJacFnB}
{
  flag = IDASlsSetSparseJacFnB(ida\_mem, which, jacB);
}
{
  The function \ID{IDASlsSetSparseJacFnB} specifies the sparse Jacobian
  approximation function to be used for the backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory returned by \id{IDACreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[jacB] (\id{IDASlsSparseJacFnB})
    user-defined sparse Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDASLS\_ILL\_INPUT]
  \item[\Id{IDASLS\_SUCCESS}] 
    \id{IDASlsSetSparseJacFnB} succeeded.
  \item[\Id{IDASLS\_MEM\_NULL}]
    The \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDASLS\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDASLS\_LMEM\_NULL}]
    The linear solver has not been initialized with a call to \id{IDAKLUB}
    or \id{IDASuperLUMTB}.
  \item[\Id{IDASLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{IDASlsSparseJacFnB} is described in \S\ref{ss:sparsejac_b}.
}


\index{Jacobian approximation function!sparse!user-supplied (backward)}
\ucfunction{IDASlsSetSparseJacFnBS}
{
  flag = IDASlsSetSparseJacFnBS(ida\_mem, which, jacBS);
}
{
  The function \ID{IDASlsSetSparseJacFnBS} specifies the sparse Jacobian
  approximation function to be used for the backward problem, in the case
  where the backward problem depends on the forward sensitivities.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory returned by \id{IDACreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[jacBS] (\id{IDASlsSparseJacFnBS})
    user-defined sparse Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDASLS\_ILL\_INPUT]
  \item[\Id{IDASLS\_SUCCESS}] 
    \id{IDASlsSetSparseJacFnBS} succeeded.
  \item[\Id{IDASLS\_MEM\_NULL}]
    The \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDASLS\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDASLS\_LMEM\_NULL}]
    The linear solver has not been initialized with a call to \id{IDAKLUB}
    or \id{IDASuperLUMTB}.
  \item[\Id{IDASLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{IDASlsSparseJacFnBS} is described in \S\ref{ss:sparsejac_b}.
}
\index{IDASUPERLUMT@{\idasuperlumt} linear solver!optional input|)}
\index{IDAKLU@{\idaklu} linear solver!optional input|)}
\index{optional input!sparse linear solver|)}


\subsubsection{SPILS linear solvers}
\index{optional input!iterative linear solver|(}
\index{IDASPGMR@{\idaspgmr} linear solver!optional input|(}
\index{IDASPBCG@{\idaspbcg} linear solver!optional input|(}
\index{IDASPTFQMR@{\idasptfqmr} linear solver!optional input|(}
Optional inputs for the {\idaspils} linear solver module can be set for the backward
problem through the following functions:
%%
\index{preconditioning!user-supplied|(}
\ucfunction{IDASpilsSetPreconditionerB}
{
  flag = IDASpilsSetPreconditionerB(ida\_mem, which, psetupB, psolveB);
}
{
  The function \ID{IDASpilsSetPrecSolveFnB} specifies the preconditioner
  setup and solve functions for the backward integration.
}
{
  \begin{args}[psetupB]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[psetupB] (\id{IDASpilsPrecSetupFnB})
    user-defined preconditioner setup function.
  \item[psolveB] (\id{IDASpilsPrecSolveFnB})
    user-defined preconditioner solve function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDASPILS\_ILL\_INPUT]
  \item[\Id{IDASPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} memory block pointer was \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    The {\idaspils} linear solver has not been initialized.
  \item[\Id{IDASPILS\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDASPILS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
   The function types \id{IDASpilsPrecSolveFnB} and \id{IDASpilsPrecSetupFnB} are
   described in \S\ref{ss:psolve_b} and \S\ref{ss:psetup_b}, respectively.
   The \id{psetupB} argument may be \id{NULL} if no setup operation is involved
   in the preconditioner.
}

\ucfunction{IDASpilsSetPreconditionerBS}
{
  flag = IDASpilsSetPreconditionerBS(ida\_mem, which, psetupBS, psolveBS);
}
{
  The function \ID{IDASpilsSetPrecSolveFnBS} specifies the preconditioner
  setup and solve functions for the backward integration, in the case
  where the backward problem depends on the forward sensitivities.
}
{
  \begin{args}[psetupBS]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[psetupBS] (\id{IDASpilsPrecSetupFnBS})
    user-defined preconditioner setup function.
  \item[psolveBS] (\id{IDASpilsPrecSolveFnBS})
    user-defined preconditioner solve function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDASPILS\_ILL\_INPUT]
  \item[\Id{IDASPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} memory block pointer was \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    The {\idaspils} linear solver has not been initialized.
  \item[\Id{IDASPILS\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDASPILS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
   The function types \id{IDASpilsPrecSolveFnBS} and \id{IDASpilsPrecSetupFnBS} are
   described in \S\ref{ss:psolve_b} and \S\ref{ss:psetup_b}, respectively.
   The \id{psetupBS} argument may be \id{NULL} if no setup operation is involved
   in the preconditioner.
}
%%
\index{preconditioning!user-supplied|)}
%%
%%
\index{Jacobian approximation function!Jacobian-vector product!user-supplied (backward)}
\ucfunction{IDASpilsSetJacTimesVecFnB}
{
  flag = IDASpilsSetJacTimesVecFnB(ida\_mem, which, jtvB);
}
{
  The function \ID{IDASpilsSetJacTimesVecFnB} specifies the Jacobian-vector 
  product function to be used.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[jtvB] (\id{IDASpilsJacTimesVecFnB})
    user-defined Jacobian-vector product function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDASPILS\_ILL\_INPUT]
  \item[\Id{IDASPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} memory block pointer was \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    The {\idaspils} linear solver has not been initialized.
  \item[\Id{IDASPILS\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDASPILS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{IDASpilsJacTimesVecFnB} is described in
  \S\ref{ss:jactimesvec_b}.
}
%%
\ucfunction{IDASpilsSetJacTimesVecFnBS}
{
  flag = IDASpilsSetJacTimesVecFnBS(ida\_mem, which, jtvBS);
}
{
  The function \ID{IDASpilsSetJacTimesVecFnBS} specifies the Jacobian-vector 
  product function to be used, in the case where the backward problem depends
  on the forward sensitivities.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[jtvBS] (\id{IDASpilsJacTimesVecFnBS})
    user-defined Jacobian-vector product function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDASPILS\_ILL\_INPUT]
  \item[\Id{IDASPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} memory block pointer was \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    The {\idaspils} linear solver has not been initialized.
  \item[\Id{IDASPILS\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDASPILS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{IDASpilsJacTimesVecFnBS} is described in
  \S\ref{ss:jactimesvec_b}.
}
%%
%%
\ucfunction{IDASpilsSetGSTypeB}
{
  flag = IDASpilsSetGSType(ida\_mem, which, gstypeB);
}
{
  The function \ID{IDASpilsSetGSTypeB} specifies the type of
  Gram-Schmidt orthogonalization to be used with {\idaspgmr}.
  This must be one of the enumeration constants \ID{MODIFIED\_GS}
  or \ID{CLASSICAL\_GS}. These correspond to using modified Gram-Schmidt 
  and classical Gram-Schmidt, respectively. 
  \index{Gram-Schmidt procedure}
}
{
  \begin{args}[gstypeB]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[gstypeB] (\id{int})
    type of Gram-Schmidt orthogonalization.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDASPILS\_ILL\_INPUT]
  \item[\Id{IDASPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    The {\idaspils} linear solver has not been initialized.
  \item[\Id{IDASPILS\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDASPILS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier or the 
    value of \id{gstypeB} was not valid.
  \end{args}
}
{
  The default value is \id{MODIFIED\_GS}.

  {\warn}This option is available only with {\idaspgmr}.
}
%%
%%
\ucfunction{IDASpilsSetMaxlB}
{
  flag = IDASpilsSetMaxlB(ida\_mem, which, maxlB);
}
{
  The function \ID{IDASpilsSetMaxlB} resets maximum Krylov subspace
  dimension for the Bi-CGStab\index{Bi-CGStab method} or TFQMR\index{TFQMR method} 
  methods.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[maxlB] (\id{realtype})
    maximum dimension of the Krylov subspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDASPILS\_ILL\_INPUT]
  \item[\Id{IDASPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    The {\idaspils} linear solver has not been initialized.
  \item[\Id{IDASPILS\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDASPILS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The maximum subspace dimension is initially specified in the call
  to \id{IDASpbcgB} or \id{IDASptfqmrB}.  The call to \id{IDASpilsSetMaxlB}
  is needed only if \id{maxlB} is being changed from its previous value.

  {\warn}This option is available only for the {\idaspbcg} and {\idasptfqmr} linear solvers.
}
%%
%%
\ucfunction{IDASpilsSetEpsLinB}
{
  flag = IDASpilsSetEpsLinB(ida\_mem, eplifacB);
}
{
  The function \ID{IDASpilsSetEpsLinB} specifies the factor by
  which the Krylov linear solver's convergence test constant is reduced
  from the Newton iteration test constant. (See \S\ref{ss:ivp_sol}).
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[eplifacB] (\id{realtype})
    linear convergence safety factor ($>= 0.0$).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_ILL\_INPUT]
  \item[\Id{IDASPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    The {\idaspils} linear solver has not been initialized.
  \item[\Id{IDASPILS\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDASPILS\_ILL\_INPUT}]
    The value of \id{eplifacB} is negative.
  \end{args}
}
{
  The default value is $0.05$.

  Passing a value \id{eplifacB}$ = 0.0$ also indicates using the default value.
}

\index{IDASPGMR@{\idaspgmr} linear solver!optional input|)}
\index{IDASPBCG@{\idaspbcg} linear solver!optional input|)}
\index{IDASPTFQMR@{\idasptfqmr} linear solver!optional input|)}
\index{optional input!iterative linear solver|)}

%---------------------------------------------------------------------------
\subsection{Optional output functions for the backward problem}
\label{ss:optional_output_b}
%---------------------------------------------------------------------------

\subsubsection{Main solver optional output functions}
\index{optional output!backward solver|(}

The user of the adjoint module in {\idas} has access to any of the
optional output functions described in \S\ref{ss:optional_output},
both for the main solver and for the linear solver modules. The first
argument of these \id{IDAGet*} and \id{IDA*Get*} functions is the
pointer to the {\idas} memory block for the backward problem. In order
to call any of these functions, the user must first call the following
function to obtain this pointer:
%%
\ucfunction{IDAGetAdjIDABmem}
{
  ida\_memB = IDAGetAdjIDABmem(ida\_mem, which);
}
{
  The function \ID{IDAGetAdjIDABmem} returns a pointer to the {\idas}
  memory block for the backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block created by \id{IDACreate}.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \end{args}
}
{
  The return value, \id{ida\_memB} (of type \id{void *}), is a pointer to the
  {\idas} memory for the backward problem.
}
{
  {\warn}The user should not modify \id{ida\_memB} in any way.

  Optional output calls should pass \id{ida\_memB} as the first argument;
  thus, for example, to get the number of integration steps:
  \id{flag = IDAGetNumSteps(idas\_memB,\&nsteps)}.
}
\index{optional output!backward solver|)}


To get values of the {\it forward} solution during a backward integration,
use the following function.  The input value of \id{t} would typically be
equal to that at which the backward solution has just been obtained with
\id{IDAGetB}.  In any case, it must be within the last checkpoint interval
used by \id{IDASolveB}.

\ucfunction{IDAGetAdjY}
{
  flag = IDAGetAdjY(ida\_mem, t, y, yp);
}
{
  The function \ID{IDAGetAdjY} returns the interpolated value of the
 forward solution $y$ and its derivative during a backward integration.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block created by \id{IDACreate}.
  \item[t] (\id{realtype})
    value of the independent variable at which $y$ is desired (input).
  \item[y] (\id{N\_Vector}) forward solution $y(t)$.
  \item[yp] (\id{N\_Vector}) forward solution derivative $\dot{y}(t)$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
 \begin{args}[IDA\_GETY\_BADT]
  \item[\Id{IDA\_SUCCESS}] 
    \id{IDAGetAdjY} was successful. 
  \item[\Id{IDA\_MEM\_NULL}]
    \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDA\_GETY\_BADT}]
    The value of \id{t} was outside the current checkpoint interval.
  \end{args}
}
{
  {\warn} The user must allocate space for \id{y} and \id{yp}.
}

%%
\subsubsection{Initial condition calculation optional output function}
\label{sss:optout_iccalcB}
\index{optional output!backward initial condition calculation|(}
%%

\ucfunction{IDAGetConsistentICB}
{
  flag = IDAGetConsistentICB(ida\_mem, which, yB0\_mod, ypB0\_mod);
}
{
  The function \ID{IDAGetConsistentICB} returns the corrected initial conditions
  for backward problem calculated by \id{IDACalcICB}.
}
{
  \begin{args}[ypB0\_mod]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which]
    is the identifier of the backward problem.
  \item[yB0\_mod] (\id{N\_Vector})
    consistent initial vector.
  \item[ypB0\_mod] (\id{N\_Vector})
    consistent initial derivative vector.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_ILL\_INPUT]
  \item[IDA\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDA\_NO\_ADJ}]
    \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDA\_ILL\_INPUT}]
    Parameter \id{which} did not refer a valid backward problem identifier.
  \end{args}
}
{
  If the consistent solution vector or consistent derivative vector
  is not desired, pass \id{NULL} for the corresponding argument.

  {\warn} The user must allocate space for \id{yB0\_mod} and \id{ypB0\_mod}
  (if not \id{NULL}).
}
%%
\index{optional output!backward initial condition calculation|}

%%---------------------------------------------------------------------
\subsection{Backward integration of quadrature equations}
%%---------------------------------------------------------------------

Not only the backward problem but also the backward quadrature equations 
may or may not depend on the forward sensitivities. Accordingly, one of the 
\id{IDAQuadInitB} or \id{IDAQuadInitBS} should be used to allocate internal 
memory and to initialize backward quadratures.  For any other operation
(extraction, optional input/output, reinitialization, deallocation), the
same function is called regardless of whether or not the quadratures are
sensitivity-dependent.

\subsubsection{Backward quadrature initialization functions}
\label{sss:idaquadinitb}

The function \id{IDAQuadInitB} initializes and allocates memory for the backward
integration of quadrature equations that do not depende on forward sensititvities.
It has the following form:
%%
%%
\ucfunction{IDAQuadInitB}
{
flag = IDAQuadInitB(ida\_mem, which, rhsQB, yQB0);
}
{
  The function \ID{IDAQuadInitB} provides required problem specifications,
  allocates internal memory, and initializes backward quadrature integration.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[rhsQB] (\Id{IDAQuadRhsFnB})
    is the {\C} function which computes $fQB$, the residual of the 
    backward quadrature equations. This function has the form 
    \id{rhsQB(t, y, yp, yB, ypB, rhsvalBQ, user\_dataB)} 
    (see \S\ref{sss:rhs_quad_B}).
  \item[yQB0] (\id{N\_Vector})
    is the value of the quadrature variables at \id{tB0}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDAQuadInitB} was successful.
  \item[\Id{IDA\_MEM\_NULL}] 
    \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDA\_MEM\_FAIL}] 
    A memory allocation request has failed.
  \item[\Id{IDA\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args}
}
{}
%%
%%

The function \id{IDAQuadInitBS} initializes and allocates memory for the backward
integration of quadrature equations that depend on the forward sensitivities.
%%
%%
\ucfunction{IDAQuadInitBS}
{
flag = IDAQuadInitBS(ida\_mem, which, rhsQBS, yQBS0);
}
{
  The function \ID{IDAQuadInitBS} provides required problem specifications,
  allocates internal memory, and initializes backward quadrature integration.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[rhsQBS] (\Id{IDAQuadRhsFnBS})
    is the {\C} function which computes $fQBS$, the residual of the 
    backward quadrature equations. This function has the form 
    \id{rhsQBS(t, y, yp, yS, ypS, yB, ypB, rhsvalBQS, user\_dataB)} 
    (see \S\ref{sss:rhs_quad_sens_B}).
  \item[yQBS0] (\id{N\_Vector})
    is the value of the sensitivity-dependent quadrature variables at \id{tB0}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDAQuadInitBS} was successful.
  \item[\Id{IDA\_MEM\_NULL}] 
    \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDA\_MEM\_FAIL}] 
    A memory allocation request has failed.
  \item[\Id{IDA\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args}
}
{}


The integration of quadrature equations during the backward phase can be
re-initialized by calling
%%
%%
\ucfunction{IDAQuadReInitB}
{
  flag = IDAQuadReInitB(ida\_mem, which, yQB0);
}
{
  The function \ID{IDAQuadReInitB} re-initializes the backward quadrature integration.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[yQB0] (\id{N\_Vector})
    is the value of the quadrature variables at \id{tB0}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDAQuadReInitB} was successful.
 \item[\Id{IDA\_MEM\_NULL}] 
    \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDA\_MEM\_FAIL}] 
    A memory allocation request has failed.
  \item[\Id{IDA\_NO\_QUAD}] 
    Quadrature integration was not activated through a  previous 
    call to \id{IDAQuadInitB}.
  \item[\Id{IDA\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args}
}
{
  \id{IDAQuadReInitB} can be used after a call to either \id{IDAQuadInitB}
  or \id{IDAQuadInitBS}.
}

\subsubsection{Backward quadrature extraction function}
\label{sss:quad_get_b}
To extract the values of the quadrature variables at the last return time
of \id{IDASolveB}, {\idas} provides a wrapper for the function \ID{IDAGetQuad}
(see \S\ref{ss:quad_get}). The call to this function has the form
%%
%%
\ucfunction{IDAGetQuadB}
{
  flag = IDAGetQuadB(ida\_mem, which, \&tret, yQB);
}
{
  The function \ID{IDAGetQuadB} returns the quadrature solution vector after
  a successful return from \id{IDASolveB}.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory.
  \item[tret] (\id{realtype})
    the time reached by the solver (output).
  \item[yQB] (\id{N\_Vector})
    the computed quadrature vector.
  \end{args}
}
  {\warn} The user must allocate space for \id{yQB}.
{
  The return value \id{flag} of \id{IDAGetQuadB} is one of:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}] 
    \id{IDAGetQuadB} was successful.
  \item[\Id{IDA\_MEM\_NULL}] 
    \id{ida\_mem} is \id{NULL}.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[IDA\_NO\_QUAD] 
    Quadrature integration was not initialized.
  \item[IDA\_BAD\_DKY] 
    \id{yQB} was \id{NULL}.
  \item[\Id{IDA\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args}
}
{}
%%\subsubsection{Tolerance specification functions for backward quadrature integration}

\subsubsection{Optional input/output functions for backward quadrature integration}
\label{sss:quad_optional_input_B}
\index{optional input!quadrature integration}
\index{optional output!quadrature integration}
Optional values controlling the backward integration of quadrature equations can be 
changed from their default values through calls to one of the following functions 
which are wrappers for the corresponding optional input functions defined in 
\S\ref{ss:quad_optional_input}. The user must specify  the identifier \id{which} 
of the backward problem for which the optional values are specified.

\begin{verbatim}
  flag = IDASetQuadErrConB(ida_mem, which, errconQ);
  flag = IDAQuadSStolerancesB(ida_mem, which, reltolQ, abstolQ);
  flag = IDAQuadSVtolerancesB(ida_mem, which, reltolQ, abstolQ);
\end{verbatim}
Their return value \id{flag} (of type \id{int}) can have any of the return values 
of its counterparts, but it can also be \Id{IDA\_NO\_ADJ} if the function 
\id{IDAAdjInit} has not been previously called or \Id{IDA\_ILL\_INPUT} if the
parameter \id{which} was an invalid identifier.

Access to optional outputs related to backward quadrature integration
can be obtained by calling the corresponding \id{IDAGetQuad*}
functions (see \S\ref{ss:quad_optional_output}).  A pointer
\id{ida\_memB} to the {\idas} memory block for the backward problem,
required as the first argument of these functions, can be obtained
through a call to the functions \id{IDAGetAdjIDABmem} (see
\S\ref{ss:optional_output_b}).



%%-------------------------------------------------------------------------------------
%%-------------------------------------------------------------------------------------
\section{User-supplied functions for adjoint sensitivity analysis}
\label{ss:user_fct_adj}
%%-------------------------------------------------------------------------------------
%%-------------------------------------------------------------------------------------
%%

In addition to the required DAE residual function and any optional functions
for the forward problem, when using the adjoint sensitivity module in {\idas},
the user must supply one function defining the backward problem DAE and, optionally,
functions to supply Jacobian-related information and one or two functions 
that define the preconditioner (if one of the {\idaspils} solvers is
selected) for the backward problem.
Type definitions for all these user-supplied functions are given below.

\subsection{DAE residual for the backward problem}\label{ss:DAEres_b}
\index{adjoint sensitivity analysis!residual evaluation}
\index{residual function!backward problem}

The user must provide a \id{resB} function of type \ID{IDAResFnB} defined as follows:
\usfunction{IDAResFnB}
{
  typedef int (*IDAResFnB)(&realtype t, N\_Vector y, N\_Vector yp, \\
                           &N\_Vector yB, N\_Vector ypB, \\
                           &N\_Vector resvalB, void *user\_dataB);
}
{
  This function evaluates the residual of the backward problem DAE system.
  This could be (\ref{e:adj_eqns}) or (\ref{e:adj1_eqns}).
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the output vector containing the residual for the backward DAE problem.
  \item[user\_dataB]
    is a pointer to user data, same as passed to \id{IDASetUserDataB}.
  \end{args}
}
{
  An \id{IDAResFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\idas} will attempt to correct), or a negative 
  value if an unrecoverabl failure occurred (in which case the integration stops and
  \id{IDASolveB} returns \Id{IDA\_RESFUNC\_FAIL}).
}
{
  Allocation of memory for \id{resvalB} is handled within {\idas}.

  The \id{y}, \id{yp}, \id{yB}, \id{ypB}, and \id{resvalB} arguments are all 
  of type \id{N\_Vector}, but \id{yB}, \id{ypB}, and \id{resvalB} typically have 
  different internal representations from \id{y} and \id{yp}.  It is the user's 
  responsibility to access the vector data consistently (including the use of the 
  correct accessor macros from each {\nvector} implementation). For the sake of 
  computational efficiency, the vector functions in the two {\nvector} implementations 
  provided with {\idas} do not perform any consistency checks with respect to their 
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  The \id{user\_dataB} pointer is passed to 
  the user's \id{resB} function every time it is called and can be the same as the 
  \id{user\_data} pointer used for the forward problem.

  {\warn}Before calling the user's \id{resB} function, {\idas} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\idas} triggers an unrecoverable
  failure in the residual function which will halt the integration and
  \id{IDASolveB} will return \id{IDA\_RESFUNC\_FAIL}.
}

\subsection{DAE residual for the backward problem depending on the forward sensitivities}\label{ss:DAEres_bs}
\index{adjoint sensitivity analysis!residual evaluation}
\index{residual function!backward problem}

The user must provide a \id{resBS} function of type \ID{IDAResFnBS} defined as follows:
\usfunction{IDAResFnBS}
{
  typedef int (*IDAResFnBS)(&realtype t, N\_Vector y, N\_Vector yp, \\
                           &N\_Vector *yS, N\_Vector *ypS, \\
                           &N\_Vector yB, N\_Vector ypB, \\
                           &N\_Vector resvalB, void *user\_dataB);
}
{
  This function evaluates the residual of the backward problem DAE system.
  This could be (\ref{e:adj_eqns}) or (\ref{e:adj1_eqns}).
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities of 
    the forward solution.
  \item[ypS]
    a pointer to an array of \id{Ns} vectors containing the derivatives of 
    the forward sensitivities.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the output vector containing the residual for the backward DAE problem.
  \item[user\_dataB]
    is a pointer to user data, same as passed to \id{IDASetUserDataB}.
  \end{args}
}
{
  An \id{IDAResFnBS} should return 0 if successful, a positive value if a
  recoverable error occurred (in which case {\idas} will attempt to correct),
  or a negative value if an unrecoverable error occurred (in which case the
  integration stops and \id{IDASolveB} returns \Id{IDA\_RESFUNC\_FAIL}).
}
{
  Allocation of memory for \id{resvalB} is handled within {\idas}.

  The \id{y}, \id{yp}, \id{yB}, \id{ypB}, and \id{resvalB} arguments are all 
  of type \id{N\_Vector}, but \id{yB}, \id{ypB}, and \id{resvalB} typically have 
  different internal representations from \id{y} and \id{yp}. Likewise for each
  \id{yS[i]} and \id{ypS[i]}. It is the user's 
  responsibility to access the vector data consistently (including the use of the 
  correct accessor macros from each {\nvector} implementation). For the sake of 
  computational efficiency, the vector functions in the two {\nvector} implementations 
  provided with {\idas} do not perform any consistency checks with respect to their 
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  The \id{user\_dataB} pointer is passed to 
  the user's \id{resBS} function every time it is called and can be the same as the 
  \id{user\_data} pointer used for the forward problem.

  {\warn}Before calling the user's \id{resBS} function, {\idas} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\idas} triggers an unrecoverable
  failure in the residual function which will halt the integration and
  \id{IDASolveB} will return \id{IDA\_RESFUNC\_FAIL}.
}


%%-------------------------------------------------------------------------------------
\subsection{Quadrature right-hand side for the backward problem}
\index{residual function!quadrature backward problem}
\index{adjoint sensitivity analysis!quadrature evaluation}
\label{sss:rhs_quad_B}
The user must provide an \id{fQB} function of type \ID{IDAQuadRhsFnB} defined by
\usfunction{IDAQuadRhsFnB}
{
  typedef int (*IDAQuadRhsFnB)(&realtype t, N\_Vector y, N\_Vector yp, \\
                               &N\_Vector yB, N\_Vector ypB, \\
                               &N\_Vector rhsvalBQ, void *user\_dataB);
}
{
  This function computes the quadrature equation right-hand side for the
  backward problem.
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[rhsvalBQ]
    is the output vector containing the residual for the backward quadrature
    equations.
  \item[user\_dataB]
    is a pointer to user data, same as passed to \id{IDASetUserDataB}.
  \end{args}
}
{
  An \id{IDAQuadRhsFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\idas} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \id{IDASolveB} returns \Id{IDA\_QRHSFUNC\_FAIL}).
}
{
  Allocation of memory for \id{rhsvalBQ} is handled within {\idas}.

  The \id{y}, \id{yp}, \id{yB}, \id{ypB}, and \id{rhsvalBQ} arguments are all 
  of type \id{N\_Vector}, but they typically all have 
  different internal representations. It is the user's 
  responsibility to access the vector data consistently (including the use of the 
  correct accessor macros from each {\nvector} implementation). For the sake of 
  computational efficiency, the vector functions in the two {\nvector} implementations 
  provided with {\idas} do not perform any consistency checks with repsect to their 
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  The \id{user\_dataB} pointer is passed to the user's \id{fQB} function every time 
  it is called and can be the same as the \id{user\_data} pointer used for the forward problem.

  {\warn}Before calling the user's \id{fQB} function, {\idas} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\idas} triggers an unrecoverable
  failure in the quadrature right-hand side function which will halt the integration and
  \id{IDASolveB} will return \id{IDA\_QRHSFUNC\_FAIL}.
}

\subsection{Sensitivity-dependent quadrature right-hand side for the backward problem}
\index{residual function!sensitivity-dep. quadrature backward problem}
\index{adjoint sensitivity analysis!sensitivity-dependent quadrature evaluation}
\label{sss:rhs_quad_sens_B}
The user must provide an \id{fQBS} function of type \ID{IDAQuadRhsFnBS} defined by
\usfunction{IDAQuadRhsFnBS}
{
  typedef int (*IDAQuadRhsFnBS)(&realtype t, N\_Vector y, N\_Vector yp, \\
                                &N\_Vector *yS, N\_Vector *ypS, \\ 
                                &N\_Vector yB, N\_Vector ypB, \\
                                &N\_Vector rhsvalBQS, void *user\_dataB);
}
{
  This function computes the quadrature equation residual for the
  backward problem.
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities of 
    the forward solution.
  \item[ypS]
    a pointer to an array of \id{Ns} vectors containing the derivatives of 
    the forward sensitivities.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[rhsvalBQS]
    is the output vector containing the residual for the backward quadrature
    equations.
  \item[user\_dataB]
    is a pointer to user data, same as passed to \id{IDASetUserDataB}.
  \end{args}
}
{
  An \id{IDAQuadRhsFnBS} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\idas} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \id{IDASolveB} returns \Id{IDA\_QRHSFUNC\_FAIL}).
}
{
  Allocation of memory for \id{rhsvalBQS} is handled within {\idas}.

  The \id{y}, \id{yp}, \id{yB}, \id{ypB}, and \id{rhsvalBQS} arguments are all 
  of type \id{N\_Vector}, but they typically do not all have the same internal
  representations.  Likewise for each \id{yS[i]} and \id{ypS[i]}.  It is the user's 
  responsibility to access the vector data consistently (including the use of the 
  correct accessor macros from each {\nvector} implementation). For the sake of 
  computational efficiency, the vector functions in the two {\nvector} implementations 
  provided with {\idas} do not perform any consistency checks with repsect to their 
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  The \id{user\_dataB} pointer is passed to the user's \id{fQBS} function every time 
  it is called and can be the same as the \id{user\_data} pointer used for the forward
  problem.

  {\warn}Before calling the user's \id{fQBS} function, {\idas} needs to evaluate
  (through interpolation) the values of the states from the forward integration.
  If an error occurs in the interpolation, {\idas} triggers an unrecoverable
  failure in the quadrature right-hand side function which will halt the integration and
  \id{IDASolveB} will return \id{IDA\_QRHSFUNC\_FAIL}.
}


%%-------------------------------------------------------------------------------------
\subsection{Jacobian information for the backward problem 
  (direct method with dense Jacobian)}\label{ss:densejac_b}
  
If the direct linear solver with dense treatment of the Jacobian is selected
for the backward problem (i.e. \Id{IDADenseB} or \Id{IDALapackDenseB} is called
in step \ref{i:lin_solverB} of \S\ref{ss:skeleton_adj}), the user may provide,
through a call to \id{IDADlsSetDenseJacFnB} or \id{IDADlsSetDenseJacFnBS}
(see \S\ref{ss:optional_input_b}), a function of one of the following two types:
%%
\index{Jacobian approximation function!dense!user-supplied (backward)}
\usfunction{IDADlsDenseJacFnB}
{
  typedef int (*IDADlsDenseJacFnB)(&long int NeqB, realtype tt,\\
                               &realtype cjB, N\_Vector yy, N\_Vector yp,\\
                               &N\_Vector yB, N\_Vector ypB,\\
                               &N\_Vector resvalB,\\
                               &DlsMat JacB, void *user\_dataB,\\
                               &N\_Vector tmp1B, N\_Vector tmp2B,\\
                               &N\_Vector tmp3B);
}
{
  This function computes the dense Jacobian of the backward problem (or an approximation
  to it). 
}
{
  \begin{args}[user\_dataB]
  \item[NeqB]
    is the backward problem size (number of equations).
  \item[tt]
    is the current value of the independent variable.
  \item[cjB]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[yy]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the current value of the residual for the backward problem.
  \item[JacB]
    is the output approximate dense Jacobian matrix.
  \item[user\_dataB]
    is a pointer to user data --- the parameter passed to \id{IDASetUserDataB}. 
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated  for variables of type \id{N\_Vector} which 
    can be used by \id{IDADlsDenseJacFnB} as temporary storage or work space.    
  \end{args}
}
{
  An \id{IDADlsDenseJacFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\idas} will attempt to correct, while {\idadense} sets
  \id{last\_flag} to \Id{IDADLS\_JACFUNC\_RECVR}), or a negative 
  value if it failed unrecoverably (in which case the integration is halted, \id{IDASolveB}
  returns \Id{IDA\_LSETUP\_FAIL} and {\idadense} sets \id{last\_flag} to 
  \Id{IDADLS\_JACFUNC\_UNRECVR}).
}
{
  A user-supplied dense Jacobian function must load the \id{NeqB} by \id{NeqB}
  dense matrix \id{JacB} with an approximation to the Jacobian matrix
  at the point (\id{tt},\id{yy},\id{yB}), where \id{yy} is the solution
  of the original IVP at time \id{tt} and \id{yB} is the solution of the
  backward problem at the same time.
  Only nonzero elements need to be loaded into \id{JacB} as this matrix 
  is set to zero before the call to the Jacobian function. 
  The type of \id{JacB} is \Id{DlsMat}. The user is referred to 
  \S\ref{ss:djacFn} for details regarding accessing a \id{DlsMat} object.

  {\warn}Before calling the user's \id{IDADlsDenseJacFnB}, {\idas} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\idas} triggers an unrecoverable
  failure in the Jacobian function which will halt the integration
  (\id{IDASolveB} returns \id{IDA\_LSETUP\_FAIL} and {\idadense} sets \id{last\_flag} to 
  \Id{IDADLS\_JACFUNC\_UNRECVR}).
}

\index{Jacobian approximation function!dense!user-supplied (backward)}
\usfunction{IDADlsDenseJacFnBS}
{
  typedef int (*IDADlsDenseJacFnBS)(&long int NeqB, realtype tt,\\
                               &realtype cjB, N\_Vector yy, N\_Vector yp,\\
                               &N\_Vector *yS, N\_Vector *ypS,\\
                               &N\_Vector yB, N\_Vector ypB,\\
                               &N\_Vector resvalB,\\
                               &DlsMat JacB, void *user\_dataB,\\
                               &N\_Vector tmp1B, N\_Vector tmp2B,\\
                               &N\_Vector tmp3B);
}
{
  This function computes the dense Jacobian of the backward problem (or an
  approximation to it), in the case where the backward problem depends on the
  forward sensitivities.
}
{
  \begin{args}[user\_dataB]
  \item[NeqB]
    is the backward problem size (number of equations).
  \item[tt]
    is the current value of the independent variable.
  \item[cjB]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[yy]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities
    of the forward solution.
  \item[ypS]
    a pointer to an array of \id{Ns} vectors containing the derivatives
    of the forward solution sensitivities.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the current value of the residual for the backward problem.
  \item[JacB]
    is the output approximate dense Jacobian matrix.
  \item[user\_dataB]
    is a pointer to user data --- the parameter passed to \id{IDASetUserDataB}. 
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated  for variables of type \id{N\_Vector} which 
    can be used by \id{IDADlsDenseJacFnBS} as temporary storage or work space.    
  \end{args}
}
{
  An \id{IDADlsDenseJacFnBS} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\idas} will attempt to correct, while {\idadense} sets
  \id{last\_flag} to \Id{IDADLS\_JACFUNC\_RECVR}), or a negative 
  value if it failed unrecoverably (in which case the integration is halted, \id{IDASolveB}
  returns \Id{IDA\_LSETUP\_FAIL} and {\idadense} sets \id{last\_flag} to 
  \Id{IDADLS\_JACFUNC\_UNRECVR}).
}
{
  A user-supplied dense Jacobian function must load the \id{NeqB} by \id{NeqB}
  dense matrix \id{JacB} with an approximation to the Jacobian matrix
  at the point (\id{tt},\id{yy},\id{yS},\id{yB}), where \id{yy} is the solution
  of the original IVP at time \id{tt}, \id{yS} is the array of forward sensitivities
  at time \id{tt}, and \id{yB} is the solution of the backward problem at the same time.
  Only nonzero elements need to be loaded into \id{JacB} as this matrix 
  is set to zero before the call to the Jacobian function. 
  The type of \id{JacB} is \Id{DlsMat}. The user is referred to 
  \S\ref{ss:djacFn} for details regarding accessing a \id{DlsMat} object.

  {\warn}Before calling the user's \id{IDADlsDenseJacFnBS}, {\idas} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\idas} triggers an unrecoverable
  failure in the Jacobian function which will halt the integration
  (\id{IDASolveB} returns \id{IDA\_LSETUP\_FAIL} and {\idadense} sets \id{last\_flag} to 
  \Id{IDADLS\_JACFUNC\_UNRECVR}).
}


%%-------------------------------------------------------------------------------------
\subsection{Jacobian information for the backward problem
  (direct method with banded Jacobian)}\label{ss:bandjac_b}
\index{Jacobian approximation function!band!user-supplied (backward)}
If the direct linear solver with banded treatment of the Jacobian is selected
for the backward problem (i.e. \Id{IDABandB} or \Id{IDALapackBandB} is called in
step \ref{i:lin_solverB} of \S\ref{ss:skeleton_adj}), the user may provide,
through a call to \id{IDADlsSetBandJacFnB} or \id{IDADlsSetBandJacFnBS}
(see \S\ref{ss:optional_input_b}), a function of one of the following
two types:
%%
\usfunction{IDADlsBandJacFnB}
{
 typedef int (*IDADlsBandJacFnB)(&long int NeqB,\\
                                 &long int mupperB, long int mlowerB,\\
                                 &realtype tt, realtype cjB,\\
                                 &N\_Vector yy, N\_Vector yp,\\
                                 &N\_Vector yB, N\_Vector ypB,\\
                                 &N\_Vector resvalB, DlsMat JacB,\\
                                 &void *user\_dataB,\\
                                 &N\_Vector tmp1B, N\_Vector tmp2B,\\
                                 &N\_Vector tmp3B);
}
{
  This function computes the banded Jacobian of the backward problem
  (or a banded approximation to it).
}
{
  \begin{args}[user\_dataB]
  \item[NeqB]
    is the backward problem size.
  \item[mlowerB]
  \item[mupperB]
    are the lower and upper half-bandwidth of the Jacobian.
  \item[tt]
    is the current value of the independent variable.
  \item[cjB]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[yy]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the current value of the residual for the backward problem.
  \item[JacB]
    is the output approximate band Jacobian matrix. 
  \item[user\_dataB]
    is a pointer to user data --- the parameter passed to \id{IDASetUserDataB}. 
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated  for variables of type \id{N\_Vector} which 
    can be used by \id{IDADlsBandJacFnB} as temporary storage or work space.    
  \end{args}
}
{
  An \id{IDADlsBandJacFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\idas} will attempt to correct, while {\idaband} sets
  \id{last\_flag} to \Id{IDADLS\_JACFUNC\_RECVR}), or a negative 
  value if it failed unrecoverably (in which case the integration is halted, \id{IDASolveB}
  returns \Id{IDA\_LSETUP\_FAIL} and {\idadense} sets \id{last\_flag} to
  \Id{IDADLS\_JACFUNC\_UNRECVR}).
}
{
  A user-supplied band Jacobian function must load the band matrix \id{JacB}
  (of type \Id{DlsMat}) with the elements of the Jacobian at the
  point (\id{tt},\id{yy},\id{yB}), where \id{yy} is the solution
  of the original IVP at time \id{tt} and \id{yB} is the solution of the
  backward problem at the same time.  
  Only nonzero elements need to be loaded into
  \id{JacB} because \id{JacB} is preset to zero before the call to the
  Jacobian function. More details on the accessor macros provided for
  a \id{DlsMat} object and on the rest of the arguments passed to a function
  of type \id{IDADlsBandJacFnB} are given in \S\ref{ss:bjacFn}.

  {\warn}Before calling the user's \id{IDADlsBandJacFnB}, {\idas} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\idas} triggers an unrecoverable
  failure in the Jacobian function which will halt the integration
  (\id{IDASolveB} returns \id{IDA\_LSETUP\_FAIL} and {\idaband} sets \id{last\_flag} to
  \Id{IDADLS\_JACFUNC\_UNRECVR}).
}

\usfunction{IDADlsBandJacFnBS}
{
 typedef int (*IDADlsBandJacFnBS)(&long int NeqB,\\
                                 &long int mupperB, long int mlowerB,\\
                                 &realtype tt, realtype cjB,\\
                                 &N\_Vector yy, N\_Vector yp,\\
                                 &N\_Vector *yS, N\_Vector *ypS,\\
                                 &N\_Vector yB, N\_Vector ypB,\\
                                 &N\_Vector resvalB, DlsMat JacB,\\
                                 &void *user\_dataB,\\
                                 &N\_Vector tmp1B, N\_Vector tmp2B,\\
                                 &N\_Vector tmp3B);
}
{
  This function computes the banded Jacobian of the backward problem
  (or a banded approximation to it), in the case where the backward problem
  depends on the forward sensitivities.
}
{
  \begin{args}[user\_dataB]
  \item[NeqB]
    is the backward problem size.
  \item[mlowerB]
  \item[mupperB]
    are the lower and upper half-bandwidth of the Jacobian.
  \item[tt]
    is the current value of the independent variable.
  \item[cjB]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[yy]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities
    of the forward solution.
  \item[ypS]
    a pointer to an array of \id{Ns} vectors containing the derivatives of the
    forward sensitivities.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the current value of the residual for the backward problem.
  \item[JacB]
    is the output approximate band Jacobian matrix. 
  \item[user\_dataB]
    is a pointer to user data --- the parameter passed to \id{IDASetUserDataB}. 
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated  for variables of type \id{N\_Vector} which 
    can be used by \id{IDADlsBandJacFnBS} as temporary storage or work space.    
  \end{args}
}
{
  An \id{IDADlsBandJacFnBS} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\idas} will attempt to correct, while {\idaband} sets
  \id{last\_flag} to \Id{IDADLS\_JACFUNC\_RECVR}), or a negative 
  value if it failed unrecoverably (in which case the integration is halted, \id{IDASolveB}
  returns \Id{IDA\_LSETUP\_FAIL} and {\idadense} sets \id{last\_flag} to
  \Id{IDADLS\_JACFUNC\_UNRECVR}).
}
{
  A user-supplied band Jacobian function must load the band matrix \id{JacB}
  (of type \Id{DlsMat}) with the elements of the Jacobian at the
  point (\id{tt},\id{yy},\id{yS},\id{yB}), where \id{yy} is the solution
  of the original IVP at time \id{tt}, \id{yS} is the array of forward
  sensitivities at time \id{tt}, and \id{yB} is the solution of the
  backward problem at the same time.  
  Only nonzero elements need to be loaded into
  \id{JacB} because \id{JacB} is preset to zero before the call to the
  Jacobian function. More details on the accessor macros provided for
  a \id{DlsMat} object and on the rest of the arguments passed to a function
  of type \id{IDADlsBandJacFnBS} are given in \S\ref{ss:bjacFn}.

  {\warn}Before calling the user's \id{IDADlsBandJacFnBS}, {\idas} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\idas} triggers an unrecoverable
  failure in the Jacobian function which will halt the integration
  (\id{IDASolveB} returns \id{IDA\_LSETUP\_FAIL} and {\idaband} sets \id{last\_flag} to
  \Id{IDADLS\_JACFUNC\_UNRECVR}).
}


%%-------------------------------------------------------------------------------------
\subsection{Jacobian information for the backward problem 
  (direct method with sparse Jacobian)}\label{ss:sparsejac_b}
  
If the direct linear solver with sparse treatment of the Jacobian is selected
for the backward problem (i.e. \Id{IDAKLUB} or \Id{IDASuperLUMTB} is called
in step \ref{i:lin_solverB} of \S\ref{ss:skeleton_adj}), the user must provide,
through a call to \id{IDASlsSetSparseJacFnB} or \id{IDASlsSetSparseJacFnBS}
(see \S\ref{ss:optional_input_b}), a function of one of the following two types:
%%
\index{Jacobian approximation function!sparse!user-supplied (backward)}
\usfunction{IDASlsSparseJacFnB}
{
  typedef int (*IDASlsSparseJacFnB)(&realtype tt, realtype cjB,\\
                               &N\_Vector yy, N\_Vector yp,\\
                               &N\_Vector yB, N\_Vector ypB,\\
                               &N\_Vector rrB, SlsMat JacB,\\
                               &void *user\_dataB, N\_Vector tmp1B,\\
                               &N\_Vector tmp2B, N\_Vector tmp3B);
}
{
  This function computes the sparse Jacobian of the backward problem
  (or an approximation to it). 
}
{
  \begin{args}[user\_dataB]
  \item[tt]
    is the current value of the independent variable.
  \item[cjB]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[yy]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[rrB]
    is the current value of the residual for the backward problem.
  \item[JacB]
    is the output approximate sparse Jacobian matrix.
  \item[user\_dataB]
    is a pointer to user data --- the parameter passed to \id{IDASetUserDataB}. 
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated  for variables of type \id{N\_Vector} which 
    can be used by \id{IDASlsSparseJacFnB} as temporary storage or work space.    
  \end{args}
}
{
  An \id{IDASlsSparseJacFnB} should return 0 if successful, a positive
  value if a recoverable error occurred (in which case {\idas} will
  attempt to correct, while {\idaklu} or {\idasuperlumt} sets
  \id{last\_flag} to \Id{IDASLS\_JACFUNC\_RECVR}), or a negative value
  if it failed unrecoverably (in which case the integration is halted,
  \id{IDASolveB} returns \Id{IDA\_LSETUP\_FAIL} and {\idaklu} or
  {\idasuperlumt} sets \id{last\_flag} to \Id{IDASLS\_JACFUNC\_UNRECVR}).
}
{
  A user-supplied sparse Jacobian function must load the
  compressed-sparse-column matrix \id{JacB} with an approximation to
  the Jacobian matrix at the point (\id{tt},\id{yy},\id{yB}), where
  \id{yy} is the solution of the original IVP at time \id{tt} and
  \id{yB} is the solution of the backward problem at the same time.
  Storage for \id{JacB} already exists on entry to this function,
  although the user should ensure that sufficient space is allocated
  in \id{JacB} to hold the nonzero values to be set; if the existing
  space is insufficient the user may reallocate the data and row index
  arrays as needed.  The type of \id{JacB} is \id{SlsMat}, and the
  amount of allocated space is available within the \id{SlsMat}
  structure as \id{NNZ}.  The \id{SlsMat} type is further documented
  in the Section \S\ref{s:sls}.  The user is referred to
  \S\ref{ss:sjacFn} for details regarding accessing a \id{SlsMat}
  object.

  {\warn}Before calling the user's \id{IDASlsSparseJacFnB}, {\idas}
  needs to evaluate (through interpolation) the values of the states
  from the forward integration.  If an error occurs in the
  interpolation, {\idas} triggers an unrecoverable failure in the
  Jacobian function which will halt the integration (\id{IDASolveB}
  returns \id{IDA\_LSETUP\_FAIL} and {\idaklu} or {\idasuperlumt} sets
  \id{last\_flag} to \Id{IDASLS\_JACFUNC\_UNRECVR}).
}

\index{Jacobian approximation function!sparse!user-supplied (backward)}
\usfunction{IDASlsSparseJacFnBS}
{
  typedef int (*IDASlsSparseJacFnBS)(&realtype tt, realtype cjB,\\
                               &N\_Vector yy, N\_Vector yp,\\
                               &N\_Vector *yS, N\_Vector *ypS,\\
                               &N\_Vector yB, N\_Vector ypB,\\
                               &N\_Vector rrB, SlsMat JacB,\\
                               &void *user\_dataB, N\_Vector tmp1B,\\
                               &N\_Vector tmp2B, N\_Vector tmp3B);
}
{
  This function computes the sparse Jacobian of the backward problem (or an
  approximation to it), in the case where the backward problem depends on the
  forward sensitivities.
}
{
  \begin{args}[user\_dataB]
  \item[tt]
    is the current value of the independent variable.
  \item[cjB]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[yy]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities
    of the forward solution.
  \item[ypS]
    a pointer to an array of \id{Ns} vectors containing the derivatives
    of the forward solution sensitivities.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[rrB]
    is the current value of the residual for the backward problem.
  \item[JacB]
    is the output approximate sparse Jacobian matrix.
  \item[user\_dataB]
    is a pointer to user data --- the parameter passed to \id{IDASetUserDataB}. 
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated  for variables of type \id{N\_Vector} which 
    can be used by \id{IDASlsSparseJacFnBS} as temporary storage or work space.    
  \end{args}
}
{
  An \id{IDASlsSparseJacFnBS} should return 0 if successful, a
  positive value if a recoverable error occurred (in which case
  {\idas} will attempt to correct, while {\idaklu} or {\idasuperlumt}
  sets \id{last\_flag} to \Id{IDASLS\_JACFUNC\_RECVR}), or a negative
  value if it failed unrecoverably (in which case the integration is
  halted, \id{IDASolveB} returns \Id{IDA\_LSETUP\_FAIL} and
  {\idaklu} or {\idasuperlumt} sets \id{last\_flag} to
  \Id{IDASLS\_JACFUNC\_UNRECVR}).
}
{
  A user-supplied sparse Jacobian function must load the
  compressed-sparse-column matrix \id{JacB} with an approximation to
  the Jacobian matrix at the point (\id{tt},\id{yy},\id{yS},\id{yB}),
  where \id{yy} is the solution of the original IVP at time \id{tt},
  \id{yS} is the array of forward sensitivities at time \id{tt}, and
  \id{yB} is the solution of the backward problem at the same time.
  Storage for \id{JacB} already exists on entry to this function,
  although the user should ensure that sufficient space is allocated
  in \id{JacB} to hold the nonzero values to be set; if the existing
  space is insufficient the user may reallocate the data and row index
  arrays as needed.  The type of \id{JacB} is \id{SlsMat}, and the
  amount of allocated space is available within the \id{SlsMat}
  structure as \id{NNZ}.  The \id{SlsMat} type is further documented
  in the Section \S\ref{s:sls}.  The user is referred to
  \S\ref{ss:sjacFn} for details regarding accessing a \id{SlsMat}
  object.

  {\warn}Before calling the user's \id{IDASlsSparseJacFnBS}, {\idas}
  needs to evaluate (through interpolation) the values of the states
  from the forward integration.  If an error occurs in the
  interpolation, {\idas} triggers an unrecoverable failure in the
  Jacobian function which will halt the integration (\id{IDASolveB}
  returns \id{IDA\_LSETUP\_FAIL} and {\idaklu} or {\idasuperlumt} sets
  \id{last\_flag} to \Id{IDASLS\_JACFUNC\_UNRECVR}).
}


%%-------------------------------------------------------------------------------------
\subsection{Jacobian information for the backward problem
   (matrix-vector product)}\label{ss:jactimesvec_b}
\index{Jacobian approximation function!Jacobian-vector product!user-supplied (backward)}
If one of the Krylov iterative linear solvers {\spgmr}, {\spbcg}, or {\sptfqmr}
is selected (\id{IDASp*B} is called in step \ref{i:lin_solverB} of \S\ref{ss:skeleton_adj}), 
the user may provide a function of one of the following two forms:
%%
\usfunction{IDASpilsJacTimesVecFnB}
{
  typedef int (*IDASpilsJacTimesVecFnB)(&realtype t, \\
                                        &N\_Vector yy, N\_Vector yp, \\
                                        &N\_Vector yB, N\_Vector ypB, \\
                                        &N\_Vector resvalB, \\
                                        &N\_Vector vB, N\_Vector JvB, \\
                                        &realtype cjB, void *user\_dataB, \\
                                        &N\_Vector tmp1B, N\_Vector tmp2B);
}
{
  This function computes the action of the backward problem Jacobian \id{JB}
  on a given vector \id{vB}.
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[yy]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the current value of the residual for the backward problem.
  \item[vB]
    is the vector by which the Jacobian must be multiplied.
  \item[JvB]
      is the computed output vector, \id{JB*vB}.
  \item[cjB]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}      
    parameter passed to \id{IDASetUserDataB}.
  \item[tmp1B]
  \item[tmp2B]
    are pointers to memory allocated for variables of type \id{N\_Vector} which
    can be used by \id{IDASpilsJacTimesVecFnB} as temporary storage or work space.
  \end{args}
}
{  
  The return value of a function of type \id{IDASpilsJtimesFnB} should be
  $0$ if successful or nonzero if an error was encountered, in which case
  the integration is halted.
}
{
  A user-supplied Jacobian-vector product function must load the vector \id{JvB}
  with the product of the Jacobian of the backward problem 
  at the point (\id{t}, \id{y}, \id{yB}) and the vector \id{vB}. 
  Here, \id{y} is the solution of the original IVP at time \id{t} and 
  \id{yB} is the solution of the backward problem at the same time.  
  The rest of the arguments are equivalent to those passed to a function of type
  \id{IDASpilsJacTimesVecFn} (see \S\ref{ss:jtimesFn}).
  If the backward problem is the adjoint of ${\dot y} = f(t, y)$, then this 
  function is to compute $-(\dfdyI)^T v_B$.
}

\usfunction{IDASpilsJacTimesVecFnBS}
{
  typedef int (*IDASpilsJacTimesVecFnBS)(&realtype t, \\
                                        &N\_Vector yy, N\_Vector yp, \\
                                        &N\_Vector *yyS, N\_Vector *ypS, \\
                                        &N\_Vector yB, N\_Vector ypB, \\
                                        &N\_Vector resvalB, \\
                                        &N\_Vector vB, N\_Vector JvB, \\
                                        &realtype cjB, void *user\_dataB, \\
                                        &N\_Vector tmp1B, N\_Vector tmp2B);
}
{
  This function computes the action of the backward problem Jacobian \id{JB}
  on a given vector \id{vB}, in the case where the backward problem depends
  on the forward sensitivities.
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[yy]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yyS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities of 
    the forward solution.
  \item[ypS]
    a pointer to an array of \id{Ns} vectors containing the derivatives of 
    the forward sensitivities.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the current value of the residual for the backward problem.
  \item[vB]
    is the vector by which the Jacobian must be multiplied.
  \item[JvB]
      is the computed output vector, \id{JB*vB}.
  \item[cjB]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}      
    parameter passed to \id{IDASetUserDataB}.
  \item[tmp1B]
  \item[tmp2B]
    are pointers to memory allocated for variables of type \id{N\_Vector} which
    can be used by \id{IDASpilsJacTimesVecFnBS} as temporary storage or work space.
  \end{args}
}
{  
  The return value of a function of type \id{IDASpilsJtimesFnBS} should be
  $0$ if successful or nonzero if an error was encountered, in which case
  the integration is halted.
}
{
  A user-supplied Jacobian-vector product function must load the vector \id{JvB}
  with the product of the Jacobian of the backward problem 
  at the point (\id{t}, \id{y}, \id{yB}) and the vector \id{vB}. 
  Here, \id{y} is the solution of the original IVP at time \id{t} and 
  \id{yB} is the solution of the backward problem at the same time.  
  The rest of the arguments are equivalent to those passed to a function of type
  \id{IDASpilsJacTimesVecFn} (see \S\ref{ss:jtimesFn}).
}

%%-------------------------------------------------------------------------------------
\subsection{Preconditioning for the backward problem
  (linear system solution)}\label{ss:psolve_b}
\index{preconditioning!user-supplied}
\index{IDASPGMR@{\idaspgmr} linear solver!preconditioner solve function}
\index{IDASPBCG@{\idaspbcg} linear solver!preconditioner solve function}
\index{IDASPTFQMR@{\idasptfqmr} linear solver!preconditioner solve function}
If preconditioning is used during integration of the backward problem, 
then the user must provide a {\C} function to solve the linear system 
$Pz = r$, where $P$ is a left preconditioner matrix.
This function must have one of the following two forms:
%%
\usfunction{IDASpilsPrecSolveFnB}
{
  typedef int (*IDASpilsPrecSolveFnB)(&realtype t, \\
                                     &N\_Vector yy, N\_Vector yp, \\
                                     &N\_Vector yB, N\_Vector ypB, \\
                                     &N\_Vector resvalB, \\
                                     &N\_Vector rvecB, N\_Vector zvecB, \\
                                     &realtype cjB, realtype deltaB, \\
                                     &void *user\_dataB, N\_Vector tmpB);
}
{
  This function solves the preconditioning system $Pz = r$ for the backward problem.
}
{  
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[yy]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the current value of the residual for the backward problem.
  \item[rvecB]
    is the right-hand side vector $r$ of the linear system to be solved.
  \item[zvecB]
    is the computed output vector.
  \item[cjB]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[deltaB]
    is an input tolerance to be used if an iterative method 
    is employed in the solution.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}      
    parameter passed to the function \id{IDASetUserDataB}.
  \item[tmpB]
    is a pointer to memory allocated for a variable of type    
    \id{N\_Vector} which can be used for work space.
  \end{args}
}
{
  The return value of a preconditioner solve function for the backward
  problem should be $0$ if successful, 
  positive for a recoverable error (in which case the step will be retried), or
  negative for an unrecoverable error (in which case the integration is halted).
}
{}

\usfunction{IDASpilsPrecSolveFnBS}
{
  typedef int (*IDASpilsPrecSolveFnBS)(&realtype t, \\
                                     &N\_Vector yy, N\_Vector yp, \\
                                     &N\_Vector *yyS, N\_Vector *ypS, \\
                                     &N\_Vector yB, N\_Vector ypB, \\
                                     &N\_Vector resvalB, \\
                                     &N\_Vector rvecB, N\_Vector zvecB, \\
                                     &realtype cjB, realtype deltaB, \\
                                     &void *user\_dataB, N\_Vector tmpB);
}
{
  This function solves the preconditioning system $Pz = r$ for the backward problem,
  for the case in which the backward problem depends on the forward sensitivities.
}
{  
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[yy]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yyS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities of 
    the forward solution.
  \item[ypS]
    a pointer to an array of \id{Ns} vectors containing the derivatives of 
    the forward sensitivities.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the current value of the residual for the backward problem.
  \item[rvecB]
    is the right-hand side vector $r$ of the linear system to be solved.
  \item[zvecB]
    is the computed output vector.
  \item[cjB]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[deltaB]
    is an input tolerance to be used if an iterative method 
    is employed in the solution.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}      
    parameter passed to the function \id{IDASetUserDataB}.
  \item[tmpB]
    is a pointer to memory allocated for a variable of type    
    \id{N\_Vector} which can be used for work space.
  \end{args}
}
{
  The return value of a preconditioner solve function for the backward
  problem should be $0$ if successful, 
  positive for a recoverable error (in which case the step will be retried), or
  negative for an unrecoverable error (in which case the integration is halted).
}
{}

%%-------------------------------------------------------------------------------------
\subsection{Preconditioning for the backward problem
  (Jacobian data)}\label{ss:psetup_b}
\index{preconditioning!user-supplied}
\index{IDASPGMR@{\idaspgmr} linear solver!preconditioner setup function}
\index{IDASPBCG@{\idaspbcg} linear solver!preconditioner setup function}
\index{IDASPTFQMR@{\idasptfqmr} linear solver!preconditioner setup function}
If the user's preconditioner requires that any Jacobian-related data
be preprocessed or evaluated, then this needs to be done in a
user-supplied {\C} function of one of the following two types:
%%
\usfunction{IDASpilsPrecSetupFnB}
{
  typedef int (*IDASpilsPrecSetupFnB)(&realtype t, \\
                                     &N\_Vector yy, N\_Vector yp,  \\
                                     &N\_Vector yB, N\_Vector ypB, \\ 
                                     &N\_Vector resvalB, \\
                                     &realtype cjB, void *user\_dataB,\\
                                     &N\_Vector tmp1B, N\_Vector tmp2B, \\
                                     &N\_Vector tmp3B);
}
{
  This function preprocesses and/or evaluates Jacobian-related data needed
  by the preconditioner for the backward problem.
}
{
  The arguments of an \id{IDASpilsPrecSetupFnB} are as follows:
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[yy]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the current value of the residual for the backward problem.
  \item[cjB]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}
    parameter passed to the function \id{IDASetUserDataB}.
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated for vectors which can be used           
    as temporary storage or work space.    
  \end{args}
}
{
  The return value of a preconditioner setup function for the backward
  problem should be $0$ if successful, 
  positive for a recoverable error (in which case the step will be retried),     
  or negative for an unrecoverable error (in which case the integration is halted).
}
{}
\usfunction{IDASpilsPrecSetupFnBS}
{
  typedef int (*IDASpilsPrecSetupFnBS)(&realtype t, \\
                                     &N\_Vector yy, N\_Vector yp,  \\
                                     &N\_Vector *yyS, N\_Vector *ypS,  \\
                                     &N\_Vector yB, N\_Vector ypB, \\ 
                                     &N\_Vector resvalB, \\
                                     &realtype cjB, void *user\_dataB,\\
                                     &N\_Vector tmp1B, N\_Vector tmp2B, \\
                                     &N\_Vector tmp3B);
}
{
  This function preprocesses and/or evaluates Jacobian-related data needed
  by the preconditioner for the backward problem, in the case where the
  backward problem depends on the forward sensitivities.
}
{
  The arguments of an \id{IDASpilsPrecSetupFnBS} are as follows:
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[yy]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution vector.
  \item[yyS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities of 
    the forward solution.
  \item[ypS]
    a pointer to an array of \id{Ns} vectors containing the derivatives of 
    the forward sensitivities.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the current value of the residual for the backward problem.
  \item[cjB]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}
    parameter passed to the function \id{IDASetUserDataB}.
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated for vectors which can be used           
    as temporary storage or work space.    
  \end{args}
}
{
  The return value of a preconditioner setup function for the backward
  problem should be $0$ if successful, 
  positive for a recoverable error (in which case the step will be retried),     
  or negative for an unrecoverable error (in which case the integration is halted).
}
{}

%%
%%-------------------------------------------------------------------
%%-------------------------------------------------------------------
\section{Using the band-block-diagonal preconditioner for backward problems}
%%-------------------------------------------------------------------
%%-------------------------------------------------------------------
%%

As on the forward integration phase, the efficiency of Krylov iterative methods 
for the solution of linear systems can be greatly enhanced through preconditioning.
The band-block-diagonal preconditioner module {\idabbdpre},
provides interface functions through which it can be used on the backward integration phase.

\index{IDABBDPRE@{\idabbdpre} preconditioner!usage with adjoint module|(}
The adjoint module in {\idas} offers an interface to the band-block-diagonal
preconditioner module {\idabbdpre} described in section \S\ref{sss:idabbdpre}.
This generates a preconditioner that is a block-diagonal matrix with each
block being a band matrix and can be used with one of the Krylov linear solvers
and with the MPI-parallel vector module {\nvecp}.

In order to use the {\idabbdpre} module in the solution of the backward problem,
the user must define one or two additional functions, described at the end of this section. 

\subsection{Usage of IDABBDPRE for the backward problem}
%%
\index{IDABBDPRE@{\idabbdpre} preconditioner!user-callable functions|(}
The {\idabbdpre} module is initialized by calling the following function,
{\em after} one of the {\idaspils} linear solvers has been specified,
by calling the appropriate function (see \S\ref{sss:lin_solv_b}).
%%
%%
\ucfunction{IDABBDPrecInitB}
{
  \begin{tabular}[t]{@{}r@{}l@{}}
    flag = IDABBDPrecInitB(&ida\_mem, which, NlocalB, mudqB, mldqB,\\
                           &mukeepB, mlkeepB, dqrelyB, GresB, GcommB);
  \end{tabular}
}
{
  The function \ID{IDABBDPrecInitB} initializes and allocates
  memory for the {\idabbdpre} preconditioner for the backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[NlocalB] (\id{long int})
    local vector dimension for the backward problem.
  \item[mudqB] (\id{long int})
    upper half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[mldqB] (\id{long int})
    lower half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[mukeepB] (\id{long int})
    upper half-bandwidth of the retained banded approximate Jacobian block.
  \item[mlkeepB] (\id{long int})
    lower half-bandwidth of the retained banded approximate Jacobian block.
  \item[dqrelyB] (\id{realtype})
    the relative increment in components of \id{yB} used in the difference quotient
    approximations.  The default is \id{dqrelyB}$ = \sqrt{\text{unit roundoff}}$, which
    can be specified by passing \id{dqrely}$ = 0.0$.
  \item[GresB] (\id{IDABBDLocalFnB})
    the {\C} function which computes $G_B(t,y,\dot y, y_B, \dot y_B)$, the
    function approximating the residual of the backward problem. 
  \item[GcommB] (\id{IDABBDCommFnB})
    the optional {\C} function which performs all interprocess communication required for
    the computation of $G_B$.
  \end{args}
}
{
  If successful, \id{IDABBDPrecInitB} creates, allocates, and stores (internally
  in the {\idas} solver block) a pointer to the newly created 
  {\idabbdpre} memory block.
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDASPILS\_ILL\_INPUT]
  \item[\Id{IDASPILS\_SUCCESS}]
    The call to \id{IDABBDPrecInitB} was successful.
  \item[\Id{IDASPILS\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} argument was \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    No linear solver has been attached.
  \item[\Id{IDASPILS\_ILL\_INPUT}]
    An invalid parameter has been passed.
  \end{args}
}
{}
%%
%%
To reinitialize the {\idabbdpre} preconditioner module for the backward problem,
possibly with a change in \id{mudqB}, \id{mldqB}, or \id{dqrelyB}, call the
following function:
%%
\ucfunction{IDABBDPrecReInitB}
{
  flag = IDABBDPrecReInitB(ida\_mem, which, mudqB, mldqB, dqrelyB);
}
{
  The function \ID{IDABBDPrecReInitB} reinitializes the {\idabbdpre} preconditioner
  for the backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block returned by \id{IDACreate}.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[mudqB] (\id{long int})
    upper half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[mldqB] (\id{long int})
    lower half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[dqrelyB] (\id{realtype})
    the relative increment in components of \id{yB} used in the difference quotient
    approximations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDASPILS\_ILL\_INPUT]
  \item[\Id{IDASPILS\_SUCCESS}]
    The call to \id{IDABBDPrecReInitB} was successful.
  \item[\Id{IDASPILS\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} argument was \id{NULL}.
  \item[\Id{IDASPILS\_PMEM\_NULL}]
    The \id{IDABBDPrecInitB} has not been previously called.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    No linear solver has been attached.
  \item[\Id{IDASPILS\_ILL\_INPUT}]
    An invalid parameter has been passed.
  \end{args}
}
{}
\index{IDABBDPRE@{\idabbdpre} preconditioner!user-callable functions|)}
%%
For more details on {\idabbdpre} see \S\ref{sss:idabbdpre}.

\subsection{User-supplied functions for IDABBDPRE}
%%
\index{IDABBDPRE@{\idabbdpre} preconditioner!user-supplied functions|(}
To use the {\idabbdpre} module, the user must supply one or two functions which the
module calls to construct the preconditioner: a required function \id{GresB}
(of type \id{IDABBDLocalFnB}) which approximates the residual of the backward
problem and which is computed locally, and an optional function \id{GcommB}
(of type \id{IDABBDCommFnB}) which performs all interprocess communication necessary 
to evaluate this approximate residual (see \S\ref{sss:idabbdpre}).
The prototypes for these two functions are described below.
%%
%%
\usfunction{IDABBDLocalFnB}
{
  typedef int (*IDABBDLocalFnB)(&long int NlocalB, realtype t,  \\
                                &N\_Vector y, N\_Vector yp, \\
                                &N\_Vector yB, N\_Vector ypB, \\
                                &N\_Vector gB, void *user\_dataB);
}
{
  This \id{GresB} function loads the vector \id{gB}, an approximation to the
  residual of the backward problem, as a function of \id{t}, \id{y}, \id{yp}, 
  and \id{yB} and \id{ypB}.  
}
{
  \begin{args}[user\_dataB]
  \item[NlocalB] 
    is the local vector length for the backward problem.
  \item[t]
    is the value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[gB]
    is the output vector, $G_B(t,y,\dot y, y_B, \dot y_B)$.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \Id{user\_dataB}      
    parameter passed to \id{IDASetUserDataB}.  
  \end{args}
}
{
  An \id{IDABBDLocalFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\idas} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \id{IDASolveB} returns \Id{IDA\_LSETUP\_FAIL}). 
}
{
  This routine must assume that all interprocess communication of data needed to 
  calculate \id{gB} has already been done, and this data is accessible within
  \id{user\_dataB}.

  {\warn}Before calling the user's \id{IDABBDLocalFnB}, {\idas} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\idas} triggers an unrecoverable
  failure in the preconditioner setup function which will halt the integration
  (\id{IDASolveB} returns \id{IDA\_LSETUP\_FAIL}).
}
%%
%%
\usfunction{IDABBDCommFnB}
{
  typedef int (*IDABBDCommFnB)(&long int NlocalB, realtype t,  \\
                           &N\_Vector y, N\_Vector yp, \\
                           &N\_Vector yB, N\_Vector ypB, \\
                           &void *user\_dataB);
}
{
  This \id{GcommB} function performs all interprocess communications necessary 
  for the execution of the \id{GresB} function above, using the input 
  vectors \id{y}, \id{yp}, \id{yB} and \id{ypB}.
}
{
  \begin{args}[user\_dataB]
  \item[NlocalB] 
    is the local vector length.
  \item[t]
    is the value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \Id{user\_dataB}
    parameter passed to \id{IDASetUserDataB}.
  \end{args}
}
{
  An \id{IDABBDCommFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\idas} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \id{IDASolveB} returns \Id{IDA\_LSETUP\_FAIL}). 
}
{
  The \id{GcommB} function is expected to save communicated data in space defined within the
  structure \id{user\_dataB}. 

  Each call to the \id{GcommB} function is preceded by a call to the function that 
  evaluates the residual of the backward problem with the same \id{t}, \id{y}, \id{yp}, 
  \id{yB} and \id{ypB} arguments. If there is no additional communication needed, then 
  pass \id{GcommB} $=$ \id{NULL} to \id{IDABBDPrecInitB}.
}
\index{IDABBDPRE@{\idabbdpre} preconditioner!user-supplied functions|)}
%%
%%
\index{IDABBDPRE@{\idabbdpre} preconditioner!usage with adjoint module|)}
